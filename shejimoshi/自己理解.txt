1. 单例 
    单例就是为了可以让全局统一使用一个对象，跟flask中的蓝图有点类似，全局只有一个实例,
    比较节省空间、只有一个接入点，可以更好的进行数据同步控制
	# 保证某一个类只有一个实例，而且在全局只有一个访问点
	优点 : 全局只有一个实例, 比较节省空间、只有一个接入点，可以更好的进行数据同步控制、
	       可以常驻内存, 减少系统开销
	缺点 : 不容易扩展、单例对象的职责太多、单例在并发协作需要优先完成、可能会导致资源瓶颈  

2. 工厂模式
    比较灵活，可扩展，将一类物品抽象成一个类，每个物品对应自己的具体类(继承自抽象类)可以使用
        具体类调用抽象类的方法进行创建、获取属性，每个物品的具体类依赖于一类物品的抽象类
	四个名词 : 抽象产品类、具体产品类、抽象工厂类、具体工厂类
	定义 : 根据输入值，来返回结果，调用相同的方法，得到不同的返回值
	简单工厂模式 : 不对抽象工厂类不进行实例化, 将创建食品的方法改成类方法, 
	             直接使用抽象工厂类进行调用
	工厂模式 : 创建一个接口函数，定义一个字典，让子类决定实例化哪一个类
	抽象工厂模式 : 创建一个抽象类，通过传的参数来决定创建对象
	优点 : 封装的好、可以随时进行调整
	缺点 : 因为工厂类创建一个实例比较复杂，所以在小项目中尽量不使用工厂

3. 建造者模式
    建造者模式的意图就是想将创建过程与表示分离，它使用相同的构建步骤作用于不同的子对象以
        构建出不同表现形式的“复杂对象”
    # 可以给一个对象属性赋值为多个不同类的对象
    总结 : 作用于不一样的子对象通过一样的过程返回不一样的结果
    适用 : 需要生成的产品有复杂的内部结构

4. 代理模式
    代理模式先创建出一个代理类，方法和主题类一致，然后将主题对象作为参数代入到代理类，然后在
    另一个添加功能代理类(继承自代理类)中对主题对象一系列的操作和验证
    优点 : 职责清晰、扩展性强、保证主题对象的处理逻辑
    应用 : 针对特定对象进行增强性扩展、减轻主题对象负载、对主题对象进行保护
    缺点 : 可能会降低整体业务的处理效率和速度




