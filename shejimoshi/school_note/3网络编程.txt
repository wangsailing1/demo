**********************************************************************************************
---------------------------- 2018年11月8日 星期四 晴 day26 -------------------PythonNet(day1)--
吕泽
内容安排:
  1.网络编程   难点△
  2.进程线程   难点△
  3.正则表达式
  4.mongodb数据库
  5.git使用
  6.项目

-网络编程
  网络的功能:数据的传输
  ISO(国际标准化组织)
  
-OSI七层模型-->网络通信标准化流程  
           层与功能                                              常用协议
    应用层：提供用户服务，具体功能由程序体现                         HTTP
    表示层：数据的压缩优化和加密
    会话层：建立应用连接，选择合适的传输服务
    传输层：提供传输服务，进行流量控制                             TCP,UDP
    网络层：路由选择，网络互连                                     
    链路层：进行数据交换，控制具体消息收发，链路连接
    物理层：提供物理硬件传(输网卡，接口设置，传输介质)
            模电转换(将0101信号转换成高低电频，使之能够通过网线传输)
  优点：
    1.建立了统一的网络工作流程
    2.每个层次功能清晰，各司其职
    3.降低了耦合度，方便了开发流程
    cookie:
      编程原则：
        高内聚：模块功能尽可能单一，不要相互掺杂
        低耦合：模块之间的关联和影响尽可能少

-四层模型(TCP/IP模型)
  应用层  传输层  网络层  物理链路层
  *将七层模型的应用层、表示层、会话层统一为应用层，便于开发实践

-五层模型
  应用层  传输层  网络层  链路层  物理层

-数据的传输流程
  1.发送端由应用层起，各层根据协议给数据添加首部信息
    最终在物理层实现发送
  2.发送的消息经过中间多个节点转发到达目标主机
  3.目标主机根据协议逐层解析首部，最终到达应用层展示数据

-协议(这里指网络协议)
  网络通信双方都遵守的规定，包括建立什么数据结构，消息结构，首部内容等；

-网络编程的基本概念
  网络主机：在网络中标识一台主机的标志
    本地使用: 'localhost' 
              '127.0.0.1'

    网络使用: 用本机网络IP地址标识 '176.140.5.113' 
             或 '0.0.0.0'    写程序时可用其代表自动选择可用网卡,
                             但是其他主机访问的时候需要用本机IP
             (查询IP linux: ifconfig  windows: ipconfig)

-IP地址
  在网络上查找一台主机的网络位置
    IPv4: 点分十进制, 分四部分，每部分取值:0-255
    IPv6: 扩充地址的范围       
  网络连接测试：
    ping [ip]      
  特殊IP
    127.0.0.1      本机测试IP
    0.0.0.0        本机自动获取能够使用的网卡IP
    xxx.xxx.x.0    通常用来表示一个网段，不指向某台主机
    xxx.xxx.x.1    通常用来表示网关
    xxx.xxx.x.255  通常用来表示广播地址
  IP地址分类：
    A类地址：0-127    0.0.0.0 - 127.0.0.0
    B类地址：128-191  128.0.0.0 - 191.254.0.0 
    C类地址：192-223  192.0.0.0 - 223.254.254.0
    D类地址：224-239  224.0.0.0 - 239.255.255.255 用于组播 二进制前四位以1110引导
    E类地址：240-     240.0.0.0 -  用于研究                二进制前四位以1111引导

-域名
    网络服务器的别名
  作用：
    方便记忆，表达一定的含义

-DNS域名解析器地址
  专门用来保存域名和IP对应的数据，通过域名访问DNS，可以得到该域名对应
  的IP，从而通过IP访问相关的网站服务器    

-端口号 port
  端口号是网络地址的一部分，用于区分主机上不同的网络应用
  * 在一个系统中应用监听的端口不能重复
  取值范围：1 - -65535
    1 -- 255        一些众所周知的公用端口
    256 -- 1023     系统应用端口
    1024 -- 65535   用户自用端口，但是推荐用10000以后的端口

-网络字节序
  网络上数据传输的排列方式，避免不同主机存放数据方式不同而造成的
  冲突
      
-传输层服务
  1.面向连接的传输服务(基于TCP协议)：
    1.传输特征：
      提供可靠的数据传输，可靠性指的是传输过程中
      无丢失，无失序，无差错，无重复
      传输效率较UDP低
    2.实现手段：
      在通信前需要建立通信连接，通信结束后需要断开连接
    3.连接过程(三次握手)：
      1. client 向 server 发起连接请求
      2. server 收到client请求报文后，回复报文消息，表示可以连接
      3. client 收到server回复，再次发送报文确认，建立连接
    4.连接断开(四次挥手)：
      1. 主动方发松报文，提出断开连接
      2. 被动方接收到断开请求，立即返回报文，表示开始准备断开
      3. 被动方处理消息完毕，完成断开准备，再次发送报文，表示可以断开
      4. 主动方收到可以断开报文，发送报文给被动方，确认断开
    5.适用情况：
      对数据传输有准确性要求，传输文件较大，需要确保传输可靠性
        如：网页获取，文件下载，邮件收发，即时聊天消息等
    
  2.面向无连接的传输服务(基于UDP协议)：
    1.传输特征：
      不保证传输的可靠性，数据传输不需要提前建立连接
      传输效率高
    2.适用情况：
      网络情况较差，对传输可靠性要求不高
        如：视频聊天、群聊、广播

课程要求：
  1.OSI七层模型介绍一下，TCP/ip模型是什么?
  2.TCP服务和UDP服务有什么区别，TCP和UDP是哪层协议?
  3.简单描述一下三次握手和四次挥手过程?

-socket 模块  
  1.功能：
    提供网络编程的一系列接口功能
    * python的标准库模块
  2.简单函数示例：
    获取计算机名
    socket.gethostname()
    >>> 'tedu'
    通过域名获取主机地址
    socket.gethostbyname('localhost')
    >>> '127.0.0.1'
    获取指定服务的端口
    socket.getservbyname('mysql')
    >>> 3306 
    查看端口对应的服务程序
    socket.getservbyport(3306)
    >>> 'mysql'
    查看指定服务器信息(服务器名，别名，ip)
    socket.gethostbyaddr('www.baidu.com')

    将点分十进制IP地址转换成二进制字节流
    socket.inet_aton('192.168.1.2')

    将二进制字节转换成点分十进制IP地址
    socket.inet_ntoa(b'\xc0\xa8\x01\x02')    
  
-套接字  
    实现网络编程，进行数据传输的一种编程方案；通过socket提供的
    接口函数进行组合搭配实现 
  1.套接字分类：
    1.流式套接字(SOCK_STREAM)
      特征：面向连接的传输服务，能够保证传输可靠性，是基于TCP
           请求的一种套接字。数据传输使用字节流传输
    2.数据报套接字(SOCK_DGRAM)   
      特征：面向无连接的传输服务，不保证传输可靠，是基于UDP请求
           的一种套接字，使用数据报进行传输。

-TCP流式套接字编程
  服务端流程：socket → bind → listen → accept → send/recv → close     
    1.创建套接字:(socket)
        sockfd = socket.socket(socket_family=AF_INET,socket_type=SOCK_STREAM,proto=0)
        功能：创建套接字
        参数：socket_family    : 地址族类型   默认  AF_INET 即Ipv4的网络地址
                socket_type   : 套接字类型   默认 流式套接字 
                proto         : 通常为0，用来选择子协议，底层才会涉及到子协议类型，
                                应用层涉及不到，所以均用默认0即可
    2.绑定服务器地址:(bind)
        sockfd.bind(addr)
        功能：绑定服务器网络地址
        参数：只有一个参数，参数是 元组(ip,port) --> socket.bind(('127.0.0.1',8888))
    3.设置套接字监听:(listen)
        sockfd.listen(n)
        功能：将套接字设置为监听套接字，并创建监听队列
        参数：监听队列大小，设置3/5/10之类皆可

        * 一个监听套接字能够连接多个客户端套接字
    4.等待处理客户端连接:(accept)
        connfd,addr = sockfd.accept()
        功能：阻塞等待处理客户端连接请求
        返回值: connfd :  生成的新的客户端连接套接字
                addr   :  连接的客户端的地址 元组(ip,port)

        * 阻塞函数: 程序运行中遇到阻塞函数则暂停执行，直到阻塞条件满足后
                    再执行， input / sleep等都是阻塞函数，这里accept()也是，
                    直到有客户连入，程序才会继续执行。
    5.收发消息:(send/recv)
        data = connfd.recv(buffersize)  # 也是阻塞函数
        功能:   接收tcp消息
        参数:   每次最多接收消息大小(字节)
        返回值: 接收到的内容
        n = connfd.send(data)
        功能：  发送tcp消息
        参数：  要发送的内容(byte格式)
        返回值：发送的字节数
    6.关闭套接字:(close)
        sockfd.close()
        功能:关闭套接字
    示例：
        web/day01/tcp_server.py

  客户端流程
    1.创建套接字(必须是相同类型套接字才能通信 TCP:TCP UDP:UDP)
      
    2.请求连接
      sockfd.connect(addr)
        功能：连接服务端套接字
        参数：服务端地址
    3.消息收发
    4.关闭套接字
    示例：
      tcp_client.py
作业:
  1.对理论问题进行总结
  2.将tcp服务端客户端代码改为可以循环收发
  3.复习open文件处理方法

**********************************************************************************************
---------------------------- 2018年11月9日 星期五 晴 day27 -------------------PythonNet(day2)-- 

-TCP传输特征
  1.当一端退出时，如果连接端阻塞在recv,此时recv会立即结束阻塞
    返回空字串。
  2.如果连接端关闭，再调用send企图发送时，会出现BrokenPipeError异常
  3.网络收发缓冲区
     send → 发送缓冲区(计算机内存) --网络发送-->  接收缓冲区(接收方计算机内存)
      → recv(如果接收缓冲区为空,才会阻塞,否则不会)
    作用:
      1.减少和磁盘的交互次数
      2.协调收发速度

-TCP粘包
  1.tcp套接字是以字节流的方式传输消息，没有消息边界
  2.多次发送的内容存放到接收缓冲区，被接收函数一次接收

  影响：
    如果每次发送的内容是一个独立含义的个体，此时如果粘包
    会产生影响

  3.粘包处理
    1.人为添加消息边界
    2.将消息结构化
    3.控制消息发送速度      

-基于UDP套接字服务端流程
  1. 创建数据报套接字
    sockfd = socket.socket(AF_INET, SOCK_DGRAM)
  2.绑定服务器地址
    sockfd.bind(addr)
  3.消息收发
    data,addr = sockfd.recvfrom(buffersize)
      功能：接收UDP消息
      参数：每次最多接收消息的大小
      返回值： data    接收到的消息
              addr    消息发送方的地址
    n = sockfd.sendto(data,addr)
      功能：发送udp消息
      参数：data  要发送的内容
            addr  目标地址
      返回值： 发送字节数
  4.关闭套接字
    sockfd.close()
  示例：见 day02/udp_server.py

-基于UDP套接字客户端流程
  1.创建udp套接字
  2.消息收发
  3.关闭套接字
  示例：见udp_client.py

  * cookie:
    import sys
    使用sys.argv属性：获取命令行传入参数
    >>> python3 upd_client.py 127.0.0.1 7777

-tcp套接字和udp套接字区别
  1.tcp套接字以字节流方式传输，数据报套接字以数据报形式传输
  2.tcp传输会有粘包,udp不会(消息有边界)
  3.tcp保证传输可靠性,udp则可能会有消息丢失
    (tcp一次接收不完的数据下次会继续从接收缓冲区读取，
     udp一次接收不完的数据，剩余数据会被丢弃)
  4.tcp需要listen accept保证连接,udp不需要
  5.tcp使用send,recv收发消息,udp使用sendto recvfrom    

-补充函数
  sendall(data)
    功能:发送tcp消息(data的全部内容)
    参数:发送的内容bytes
    返回值: 发送成功返回null  
            失败则产生异常

-套接字对象属性
  scokfd.family         获取套接字地址族类型
  sockfd.typy           获取套接字类型
  sockfd.getsockname()  获取套接字地址
  sockfd.fileno()       获取套接字的文件描述符
                        文件描述符：
                          系统给每一个IO操作分配的唯一的整数，用于管理IO.这个整数
                          即IO的文件描述符
  sockfd.getpeername()  获取连接端的地址信息(必须有客户端连接到sockfd才可以使用)
  sockfd.setsockopt(level, option, value)
                        功能：设置套接字选项，丰富或者修改套接字属性功能
                              (通常创建完套接字就进行设置，设置完成再去使用该套接字)
                        参数： level   要设置的套接字选项类别    SOL_SOCKET目前能用到的常规选项
                              option   选择每个类别中具体的选项
                              value    要设置的值
  socket.getsockopt(level,option)  
                        功能：获取套接字选项值
                        参数：level     要获取的套接字选项类别
                              option    选择每个类别中具体的选项
                        返回值： 获取的值，对应setsockopt的value

-UDP通信例子  -->  广播
  广播：一点发送，多点接收
  广播地址：176.140.5.255 (通常为每个网段的最大地址)

  设置套接字可发送接收广播
  sockfd.setsockopt(SOL_SOCKET, SOL_BROADCAST, 1)  只对UDP套接字有效

  示例见bc_send.py  & bc_recv.py
  广播风暴： 一个网络中存在大量广播会占用较多的带宽，对网络产生影响

-TCP通信应用 --> HTTP协议通信
  http协议(超文本传输协议)应用层协议
  用途：网页的获取
        数据的传输
  特点：
    1.应用层协议，传输层采用tcp方式收发消息
    2.简单，灵活，很多语言都有http协议接口
    3.无状态的协议，协议本身不要求记录传输数据
    4.http1.1 支持持久连接  
  网页请求过程：
    1.客户端(浏览器)根据http协议，将用户请求转码成http格式请求
    2.客户端(浏览器)通过tcp传输，发送http请求给服务器
    3.服务端接收到http请求后进行解析
    4.服务端处理具体请求内容，整理需要的数据
    5.将数据以http响应的格式回发给客户端(流量器)
    6.浏览器接收响应，根据http协议格式解码，显示内容
  HTTP请求(request)
    请求格式
      1.请求行：具体的请求类别和请求内容
          格式： GET       /      HTTP/1.1
               请求类别  请求内容  协议版本
          http请求类别：
              GET       获取网络资源
              POST      提交一定的信息，得到反馈
              HEAD      获取网络资源的响应头
              PUT       更新服务器资源
              DELETE    删除服务器资源
              CONNECT   预留类别，目前无作用
              TRACE     测试
              OPTIONS   获取服务器信息
      2.请求头：对请求内容的基本描述
      3.<空行>
      4.请求体：请求参数和提交内容
  HTTP响应(response)
    响应格式
      1.响应行:反馈响应的基本情况
        格式： HTTP/1.1    200     OK
               协议版本   响应码  附加信息
          响应码：
            1XX     表示提示信息，请求被接收
            2XX     响应成功
            3XX     响应需要进一步操作，重定向
            4XX     客户端错误
            5XX     服务器错误
      2.响应头：对响应内容的描述信息
      3.<空行>
      4.响应体：回复给客户端的具体内容
示例：
  http_test.py      

课程要求：
  1.知道http协议的作用
  2.了解网页访问的基本流程
  3.掌握http协议 请求和响应的格式
  4.知道http请求的基本类型和响应码的含义    

-练习：(见httpserver1_0.py老师版)(见 filesr_server.py  filesr_client.py) 
  编写一个tcp客户端，一个服务端，完成文件的传输    

**********************************************************************************************
---------------------------- 2018年11月16日 星期五 晴 day28 -------------------PythonNet(day3)-
* 11月12日~11月15日请假回家 今天补12日课程

-将bytes数据按行分割(返回列表)
  request = connfd.recv(1024)
  request_lines = request.splitlines()

-IO (input output)
  在内存中存在数据交互的操作都认为是IO操作
  例：
    内存和终端交互：input print
      input: 通过终端从键盘读取数据进入内存
    和磁盘交互：
      read  write
    和网络交互：
      recv  send 

-IO密集型程序
    在程序中有大量的IO操作，而较少的cpu运算
  特点：
    消耗CPU少，效率低，耗时长

-计算密集型程序(CPU密集型)
  在程序运行中,IO操作较少，CPU计算较多，CPU消耗大，运行速度快

-IO模型
  阻塞IO  非阻塞IO  IO多路复用 事件IO  异步IO...

-阻塞IO
    阻塞IO是IO的默认形态,效率很低
  阻塞情况：
    * 因为某种条件没有达成造成的函数阻塞
      ex: accept  input  recv
    * 处理IO的事件较长产生的阻塞行为   
      ex: 大文件的读写、网络延迟等

-非阻塞IO
  1.将原本阻塞的函数通过属性的设置改变阻塞行为，变为非阻塞
    sockfd.setblocking(bool)
      功能：设置套接字为非阻塞IO
      参数：默认True表示套接字调用阻塞函数时为阻塞状态，False则为
          非阻塞状态
    示例：
      block_test.py
  2.超时监测，即设置一个最长阻塞等待时间，超时后即不再阻塞
    sockfd.settimeout(sec)
      功能：设置套接字超时时间
      参数：设置的时间，秒
    * 超时监测不能和非阻塞同用，否则超时设置没有意义

-IO多路复用
  定义：
    同时监控多个IO事件，选择其中能够执行的IO进行IO事件处理,以此形成
    可以同时操作多个IO的行为模式，避免一个IO阻塞造成其他IO均无法执行
    的情况。
  IO事件就绪：
    IO已经发生，内核需要交给应用程序处理
  具体方法：
    import select
      select方法：支持windows linux unix
      poll方法：  linux unix
      epoll方法： linux
  -select 方法
    rs,ws,xs = select(rlist, wlist, xlist[, timeout])
    功能：监控IO事件,阻塞等待IO事件发生
    参数：rlist  列表 要监控的读IO事件的句柄(等待并获取信息的IO事件)如：accept recv
         wlist   列表 要监控的写IO事件的句柄(不需要等待，可以主动处理的IO事件)如：send
                      只要wlist非空，select函数会立即返回
         xlist   列表 要监控的出错IO事件的句柄
         timeout 超时时间
    返回值：
        rs  列表 rlist中准备就绪的IO
        ws  列表 wlist中准备就绪的IO 
        xs  列表 xlist中准备就绪的IO
    示例：
      select_test.py & select_server.py
    *注意：
      1.IO多路复用占用计算机资源较少，效率高
      2.wlist中如果有IO则select立即返回处理
      3.在IO处理过程中不要出现死循环，影响IO监控
  -poll 方法
    p = select.poll()
    功能：创建poll对象
    返回值：poll对象

    p.register(fd,event)
    功能：注册要关注的IO
    参数：fd     要关注的IO对象
        event   要关注的事件
                常用事件类型：POLLIN 读IO
                            POLLOUT 写IO
                            POLLERR 出错IO
                            POLLHUP 断开连接事件
    ex:  p.register(sockfd, POLLIN|POLLERR)

    p.unregister(fd)
    功能：取消关注的IO
    参数：IO对象或者文件描述符

    events = p.poll()
    功能：阻塞监控IO事件发生
    返回值：events 列表 [(fileno,event),()...]
           每个就绪IO对应一个元组，元组中为该IO的fileno和就绪事件
    * 返回值中没有IO对象，所以通过fileno配合IO对象字典查找
      {fileno:IO_object}

    示例：
      poll_server.py
  -epoll方法
    使用方法：基本与poll相同
      * 将生成对象函数改为epoll
      * 将所有关注IO事件类型变为EPOLL类型
    epoll特点：
      * epoll是linux的专属多路复用方法
      * epoll效率比select和poll要高
      * epoll可以监控更多的IO(select最多1024)
      * epoll支持更多的触发类型(EPOLLET边缘触发)
    

-位运算
  &   按位与
  |   按位或
  ^   按位异或
  <<  左移
  >>  右移

  如 11  1011
     14  1110
    
    11 & 14   1010  一0则0
    11 | 14   1111  一1则1
    11 ^ 14   0101  相同为0不同为1
    11 << 2   101100 向左移动右侧补零
    14 >> 2   11   向右移动去掉低位

-作业
  熟练IO模型特点
  熟悉IO多路复用原理
  熟练select 和 poll
  复习类的使用 __init__ 继承 super   

**********************************************************************************************
---------------------------- 2018年11月17日 星期六 晴  -------------------PythonNet(day4)------
* 11月12日~11月15日请假回家 今天补14日课程

-结构化数据
  import struct
    原理：将部分数据类型放在一起，转换成bytes格式数据包，并且可以安装指定格式
         解析bytes数据包

  struct.Struct(fmt)
    功能：生成struct格式包对象
    参数：fmt 定制的数据结构组成
    ex: 一次性发送 1  b'Jame'  1.75
       st = struct.Struct('i4sf')   #i指整型 4s指4个bytes类型 f指float
    常用fmt:
        int    i
        bytes  ns(n代表有几个字符)
        float  f   
  
  st.pack(v1,v2,v3...)
    功能：将数据按照指定格式打包为bytes
    参数：要打包的数据
    返回值：打包后的bytes字串
    ex:
      st.pack(1, b'Jame', 1.75)
  
  st1.unpack(data)
    功能：将bytes格式数据包解析
    参数：要解析的数据包
    返回值：数据元组
    * st1的Struct格式必须与st的数据格式一致(收发双方数据结构要一致)

  示例：
    struct_send.py  &  struct_recv.py #老师版(udp套接字)
    struct_send1.py  &  struct_recv1.py #自己版(tcp套接字)

  * pack()和unpack()可以通过struct模块直接调用
    struct.pack(fmt,v1,v2...)
    struct.unpack(fmt,data)

-本地套接字
  功能：
    本地两个程序之间利用套接字进行通信的一种方法

  cookie：
    linux文件类型 b (块设备文件)
                 c (字符设备文件)
                 d (目录)
                 - (普通文件)
                 l (链接文件，类型与windows的快捷方式)
                 s (套接字文件)
                 p (管道文件)
  1.创建本地套接字
    sockfd = socket(AF_UNIX,SOCK_STREAM)
  2.绑定本地套接字文件
    sockfd.bind(path)
  3.监听
    sockfd.listen()
  4.连接
    sockfd.accept()
  5.消息收发
    recv  send
  示例：
    见unix_server.py & unix_client.py


-多任务编程
  意义：
    充分利用计算机的多核资源，同时运行多个任务，以提高程序的执行效率
  实现方法：
    多进程  多线程

-并发
  同时有多个任务发生，计算机内核在任务间不断切换以达到像多个任务同时被执行
  的效果。实际上每一时刻只有一个任务被处理。
-并行 
  多个任务利用计算机多核资源在同时执行，此时多个任务间是并行关系

-进程(process) 
  定义：
    程序在计算机中的一次运行过程
  注意程序和进程的区别：
    程序：是一个可执行的文件，是静态的，占有磁盘
    进程：是一个动态过程，占有计算机资源，有生命周期  
  进程的诞生：
    1.用户空间通过启动程序，或者调用进程创建接口发起进程创建请求
    2.操作系统接收用户请求，开始创建进程
    3.操作系统分配计算机资源，确定进程状态，开辟空间等
    4.操作系统将进程提供给用户使用

-CPU时间片：
  如果一个进程占有CPU内核，则称这个进程在CPU时间片上
-PCB(进程控制块)：process control block
  在内存中开辟的一块空间，存放进程的基本信息，也是操作系统调用进程的
  重要标记 
-进程ID(PID)：
    系统为每个进程分配一个不重复的ID号，是该进程在系统中的的标识
  查看进程信息：
    ps -aux

-父子进程：
    系统中每个进程都有唯一的父进程，可以有0个或者多个子进程
    * 进程systemd特殊,它是最高级的父进程，操作系统初始化即生成的
  查看进程数：
    pstree

-进程状态：
  三态：
    就绪态：进程具备执行条件，等待系统分配CPU
    运行态：进程占有CPU时间片运行
    等待态：进程暂时阻塞，不具备执行条件

      [就绪态]  进程诞生时
      ↓      ↑
    调度 / 时间片完成 
      ↓      ↑
      [执行态]
        ↓IO请求
      [等待/阻塞态]  →→↑ IO完成返回就绪态
  五态：
    相比三态新增了[新建态]和[终止态]
    新建态：创建一个新的进程，获取资源的过程
    终止态：进程结束，释放资源的过程
  查看进程状态：
    pa -aux 中的STAT列
  进程状态第一个字母：
    S  等待态 可中断等待态，常见的阻塞等待都是S，如accept input
    D  等待态 不可中断等待态
    T  暂停态
    R  运行态
    Z  僵尸进程
  进程状态第二个字母：
    <  有较高优先级的
    N  有较低优先级的
    +  前台进程(可以通过终端控制)
    s  会话组组长
    l  有进程链接

cookie:
  -强制结束进程
    kill -9 PID 
  -以后台进程运行：
    运行命令户加 &
    python3 hello.py &

-进程优先级
  作用：
    决定进程的优先权限和占有资源的优先程度
  linux优先级范围：
     -20 ~ 19 共40级，数字越小优先级越高
  查看优先级：
    top 中的NI列 (按Q结束top命令，按<或>翻页)
  更改优先级：
    在执行时指定 $ nice -优先级 运行命令
    如：$ nice --9 python3 hello.py *较高优先级可能需要在前面加sudo获取权限

-课程要求：
  1.什么是进程，进程和程序区别
  2.进程有哪些状态，状态之间如何转化

-进行运行特征
  1.进程可以使用计算机多核资源
  2.进程是计算机分配资源(内存空间等)的最小单位
  3.进程之间的运行互不干扰，相互独立
  4.每个进程空间独立，有自己的空间资源

-进程创建
  import os
  pid = os.fork()
    功能：创建新的进程
    返回值：失败 返回一个负数
           成功  原进程中返回新进程的PID号，新进程中返回0
  示例：
    fork.py 

  *子进程从fork的下一句开始执行 
  *父子进程各自独立运行，运行顺序不一定
  *if结构几乎是fork的固定搭配，通过父子进程的返回值区别，使其执行
   不同的代码
  *子进程会复制父进程的全部代码段和所有内存空间(变量等)，包括fork前
   开辟的所有空间；但是子进程也有之间独立的内容，如PID 指令集 PCB等
  *父子进程空间互不影响，各自操作各自空间的内容
  示例见：
   fork1.py
-作业：理解fork的使用

**********************************************************************************************
---------------------------- 2018年11月17日 星期六 晴  -------------------PythonNet(day5)------
*补15日内容
-进程函数
  os.getpid()
    功能：获取当前进程的PID号
    返回值：返回PID
  os.getppid()
    功能：获取父进程的PID号parent pid
    返回值：返回PID  
  os._exit(status)
    功能：结束进程
    参数：表示进程的退出状态 必填 通常填整数 一般用0表示正常退出
  sys.exit([status])
    功能：结束进程
    参数：表示进程的退出状态 非必填 整数 默认用0表示正常退出
          可以传字符串  进程退出时会打印该字符串

-孤儿进程
  父进程先于子进程退出，此时子进程就成为孤儿进程
  *孤儿进程会被系统进程收养，即该系统进程成为孤儿进程新的父进程  

-僵尸进程：
  子进程先于父进程退出，且父进程没有处理子进程退出行为，此时子进程就会
  成为僵尸进程
    示例见：fork_z.py  
  *僵尸进程虽然结束但是会存留部分进程信息在内存中，大量的僵尸进程会
   消耗系统资源，因此应该避免僵尸进程产生    

-如何处理僵尸进程：
  * 二级子进程
    pid,status = os.wait()
      功能：父进程中阻塞等待处理子进程的退出
      返回值：pid    退出的子进程的pid号
             status 子进程的退出状态(会默认乘以256),
                    或者用os.WEXITSTATUS(status)获取初始status状态
      示例：
        见wait.py 
        二级子进程见 sub_child.py

    pid,status = os.waitpid(pid,option)
      功能：父进程中等待处理子进程的退出
      参数：pid    -1 表示等待任意子进程退出
                   >0 表示等待对应PID的子进程退出
           option  0 表示阻塞等待
                   os.WNOHANG 表示非阻塞(非阻塞是指，运行到该行时，如果有子进程退出，则捕获，
                              如果没有则不等待，继续向下执行，在此之后退出的子进程还是会成为僵尸)
      返回值：pid    退出的子进程的pid号
             status 子进程的退出状态(会默认乘以256),
                    或者用os.WEXITSTATUS(status)获取初始status状态
-练习：
  群聊聊天室
功能：类似qq群聊
  1.进入聊天室需要输入姓名，姓名不能重复
  2.进入聊天室会向其他成员发送通知
    XXX 进入聊天室
  3.一个人发消息，其他人都会收到 
    XXX : xxxxxx
  4.某人退出聊天室，其他人也会收到通知
    XXX 退出了聊天室
  5.管理员可以从后台发送消息，此时群聊成员都收到
    管理员 : xxxxxx 
技术分析：
  发消息：UDP套接字
  成员存储：服务端 {name:addr}
  消息发送模式：客户端发给服务端，服务端转发给其他成员
  管理员：服务端 发送内容，其他人接收
  保证收发消息互不影响：使用多进程
整体设计：
  1.封装方式
  2.编写流程 先确保通信实现，逐个功能实现
  3.测试问题 实现一个功能测试一个功能
  具体功能实现：
    网络通信：
      服务端：创建UDP套接字，绑定地址
      客户端：创建套接字
示例：
  ql_server.py  & ql_client.py  

-作业：
  用两个进程分别复制一个文件的上下部分，见copy_particle.py  

*注意：
  如果子进程从父进程继承对象，则父子进程使用此对象可能会相互影响(如文件对象的偏移量)
  但是如果对象是子进程创建后，再在各自进程中生成的，则一定没有影响                

**********************************************************************************************
---------------------------- 2018年11月18日 星期日 晴  -------------------PythonNet(day6)------  
*补16日内容

-multiprocessing 模块
  功能： 
    创建多进程
  1.强制要求将需要执行的进程事件封装为函数
  2.使用模块中的Process类生成进程对象，并关联相关函数
  3.通过对象属性设置进程信息
  4.通过进程对象启动进程，此时自动运行进程函数
  5.回收进程(避免僵尸进程产生)
  *使用该模块创建的子进程不支持输入接口input

  Process()类
    功能：创建进程对象
    参数：target  绑定的目标函数(必填参数)
          name    进程名 默认'process-1' (可选参数)
          args    元组，按位置给target函数传参
          Kwargs  字典，按照键值对给target函数传参
  p.start()  p为创建的Process类的对象
    功能：启动进程
    * target绑定的函数会自动执行，此时进程真正被创建
  p.join([timeout])
    功能：阻塞等待回收进程
    参数：超时时间
  示例：
    见process1.py 多个子进程示例见process2.py
    带参数的进程函数示例 见process3.py
  *使用multiprocessing创建进程，同样子进程复制父进程全部代码空间，父子
   进程互不影响，各自运行，子进程只执行绑定的函数
  *join可以处理僵尸进程
  * multiprocessing中父进程可以更方便创建多个进程执行多个事件，父进程往往
    将事件交由子进程完成

-进程对象p的属性
  p.name        进程名称
  p.pid         进程号
  p.is_alive()  进程状态，只有正在运行时，返回True,否则均False
  p.daemon      默认是False表示主进程退出，子进程不受影响继续运行
                如果设置为True此时主进程退出，子进程也会随之结束
                * 要求在start()前设置

  示例见：
    process_attr.py

-自定义进程类
  适用情况：
    使用类将一系列功能进行封装，通过调用类中的方法完成较复杂的功能
  步骤：
    1.继承Process类
    2.编写自己的__init__添加属性，使用super同时加载父类__init__方法
    3.重写run方法，完成功能的逻辑调用
  使用：
    1.使用自定义类创建实例
    2.使用实例化对象调用start()则创建新的进程，自动运行run方法
    3.使用对象调用join()则回收进程
  示例：
    clock.py

-多进程
  优点：
    可以使用计算机多核资源，同时运行多个任务，提供运行效率
  缺点：
    进程的创建和删除过程需要消耗较多的系统资源。大量进程的频繁创建
    和销毁会给系统带来压力

-进程池技术
  适用情况：
    大量任务需要多进程完成，使用进程池可以避免频繁创建和销毁进程
  原理：
    1.事先创建一定量的进程存在进程池中，用来处理事件队列中的事件
    2.进程处理事件完毕后不退出，继续处理队列中的下一个事件
    3.直到队列中的事件全部处理完毕，再统一销毁进程池中的所有进程
  使用方法：
    1.创建进程池，放入适当的进程
    2.将要做的事件封装为函数，放入事件队列
    3.进程池中的进程会不断执行队列中的事件，直到全部被执行
    4.关闭进程池，回收进程
    from multiprocessing import Pool

    poo=Pool(processes)
      功能：创建进程池对象
      参数：指定进程池中进程数量，默认会根据系统自动判断
    poo.apply_asyns(func,args,kwds)
      功能：放入要执行的事件函数
      参数：func  事件函数
           args  元组 给函数按位置传参
           kwds  字典 给函数按键值传参
      返回值：返回函数事件对象 o 用o.get()可以获取func的返回值
  补充：
      poo.apply(func,args,kwds)
        功能：放入要执行的事件函数，以同步方式(执行完一件再到下一件)
        参数：func  事件函数
            args  元组 给函数按位置传参
            kwds  字典 给函数按键值传参
        返回值：无
      poo.map(func,iter)
        功能：将iter作为参数投入func,再把func投入进程池
        参数：func  要执行的函数
             iter  可迭代对象，用于给func传参
        返回值：函数的返回值列表
      示例：pool_map.py
        
    poo.close()
      功能：关闭进程池，无法再添加新的事件
           但进程池中已存在的事件会继续执行至完毕
    poo.join()
      功能：阻塞等待回收进程池

  示例：
    见pool.py
  * 如果主进程结束，进程池中的所有进程和事件会直接全部挂掉

-进程间通信(IPC)
  原因：
    进程空间相对独立，资源无法直接获取。此时在不同的进程间需要进行
    消息传输，即进程间通信
  进程间通信方式：管道  消息队列  共享内存  信号  信号量  套接字

-管道通信(pipe)
  通信原理：
    在内存中开辟管道空间，生成管道操作对象，进程间使用同一组管道
    对象进行读写实现通信。
  from multiprocessing import Pipe
  fd1,fd2 = Pipe(duplex = True)
    功能：创建管道
    参数：默认为True表示双向管道
          False表示单向管道
    返回值：表示管道两端的读写对象
         如果是双向管道，则fd1,fd2均可读写
         如果是单向管道，则fd1只读，fd2只写
  fd.recv()
    功能：从管道读取内容
    返回值：读到的内容
    * 如果管道为空则阻塞

  fd.send(data)
    功能：向管道写入内容
    参数：要写入的内容
    * data不局限bytes格式，可以自由写入数据
  
  示例：
    pipe.py
    
-消息队列(queue)
  队列：先进先出
  通信原理：
    在内存中建立队列模型，进程通过队列对象将消息存入到队列，或者从队列
    中去取消息；先被放入的消息一定被先取出。  
  from multiprocessing import Queue

  q = Queue(maxsize=0)
    功能：创建消息队列
    参数：表示队列中最多存放的消息的条数，默认0，系统根据内存情况自动判定
    返回值：队列对象

  q.put(data,[block,timeout])
    功能：向队列中存入消息
    参数：data    要存入的内容，任意数据类型
         block    默认队列满时会阻塞，设置为False则为非阻塞，会报错
         timeout  超时监测，阻塞时间到如果还放不进去，则报错
  
  data = q.get([block,timeout])
    功能：从队列中获取消息
    参数：block    默认队列空则阻塞，设置为False非阻塞
         timeout  超时检测
    返回值：获取到的数据

  q.full()  判断队列是否为满
  q.empty()  判断队列是否为空
  q.qsize()  获取队列中消息个数
  q.close()  关闭队列
  示例：
    queue_test.py  & queue1.py

作业：
  1.整理multiprocessing和fork创建进程方法
  2.复习tcp和upd通信
  3.复习http协议 mysql操作

**********************************************************************************************
---------------------------- 2018年11月19日 星期一 晴  -------------------PythonNet(day7)------   
* 昨天终于补完了落下的课，今天终于可以正常上课了!!!

-共享内存
  通信原理：
    在内存中开辟一个区域，对多进程可见，进程可以写入内容或读取内容，但是每次写入的内容都会
    覆盖之前的

  from multiprocessing import Value,Array

  -obj = Value(ctype,data)
    功能：开辟共享内存
    参数：ctype  字符串 表示共享内存中的数据类型
                 常用格式：
                        int         --> 'i'
                        float       --> 'f'
                        char(bytes) --> 'c'
         data    表示共享内存中的初始数据
    使用方法：
      obj.value 属性  该值即是共享内存中的值；
                      对该属性的修改和读取即是对共享的存入和读取
    示例：
      value.py
  
  -obj = Array(ctype,obj)
    功能：创建共享内存
    参数：ctype  要存储的数据类型
          obj    列表(字符串)等结构化数据  表示共享内存中的初始数据,如Array('i',[1,2,3,4,5])
                 数字  表示空间结构的大小,
                       Array('i',6)即表示可以存放6个整数的共享内存对象,这6个值都默认为0
    使用方法：
      * 可以通过遍历或者[]索引的方式获取共享内存值，或改写共享内存值
      * 如果共享内存中是字符串，可以通过obj.value获取该字符串
    示例:
      array.py

            管道        消息队列        共享内存
开辟空间     内存         内存            内存
读写方式   两端读写       先进先出        覆盖之前的内容
效率         一般         一般            较高
使用特点   多用于父子进程  第三方库较多    操作需要注意争夺内存资源
              
-信号量(信号灯)
  原理：
    给定一个数量，对多个进程可见。多个进程可以通过方法操作这个数量，达到协同工作的目的
  from multiprocessing import Semaphore

  sem = Semaphore(num)
    功能：创建信号量
    参数：初始化信号量
    返回值：信号量对象
  sem.acquire()
    功能:消耗一个信号量，当信号量为0会阻塞
  sem.release()
    功能:增加一个信号量资源
  sem.get_value()
    功能：获取信号量资源数量
  示例：
    见sem.py

-多任务编程之 线程(Thread)
  什么是线程?
    1.线程也是多任务编程方法
    2.线程也可以使用计算机多核资源
    3.线程被称为轻量级的进程，也是运行状态的概念
    4.一个进程中可以包含多个线程，线程是进程的一部分
    5.线程是系统分配内核的最小单位
  线程特征：
    1.线程也是运行状态，有生命周期，消耗资源
    2.多个线程之间独立运行，互不干扰
    3.一个进程内的线程共享进程资源
    4.线程的创建删除消耗的系统资源远远小于进程
    5.线程也有之间独立的资源，栈空间，命令集，ID等
  用法：
    threading 模块创建线程
    from threading import Thread

    t = Thread(target,args,kwargs[, name])
      功能：创建线程对象
      参数：target  绑定线程函数
           args     元组   给线程函数传参
           kwargs   字典   给线程函数传参
           name     线程名 默认 Thread-1
    
    t.start()         启动线程，自动运行线程函数
    t.join([timeout]) 阻塞等待回收线程

  * 线程没有僵尸线程，也没有孤儿线程之说，进程结束，线程就不存在了
  * 线程也没有父子线程之说，通常称之为主线程、分支线程

  示例：
    thread1.py  &  thread2.py
  线程对象属性及方法：
    t.name              线程名称
    t.setName('name1')  设置名称
    t.getName()         获取名称
    t.is_alive()        线程状态

    from threading import currentThread  
    调用currentThread()获取当前线程对象
    ↑示例：
      thread_attr.py
    
    t.daemon            默认为False此时主线程退出时分支线程继续执行
                        设置为True则主线程退出时分支线程也结束执行
    t.setDaemon(bool)   设置daemon属性，要在start()之前设置,通常不和join同用
    t.isDaemon()        查看daemon属性
    ↑示例：
      thread_attr1.py

-自定义线程类
  (与自定义进程类基本一样)
  步骤：
    1.继承Thread类
    2.添加自己的属性，并加载父类__init__
    3.重写run方法，完成功能的逻辑调用
    4.使用自定义类生成线程对象，调用start()会自动以一个线程执行run
  示例：
    myThread.py

-线程的通信
  通信方法：
    使用进程空间中的全局变量通信
  注意事项：
    共享资源争夺，往往需要同步互斥机制协调

-线程的同步和互斥
  共享资源(临界资源)：
    多个线程都可以操作的资源称为共享资源
  临界区：
    指一段代码，对临界资源操作的代码段
  同步：
    同步是一种合作关系，为完成任务，多个进程或者线程之间形成一种协调
    调度，按照必要的步骤有序执行一系列操作
  互斥：
    互斥是一种制约关系，当一个进程或者线程使用临界资源时，会加锁处理，此时
    另一个进程或者线程就无法操作，直到解锁后才能操作

-线程同步互斥方法
  线程 Event
  from threading import Event

  e = Event()
    功能：创建事件对象(事件对象初始为未设置状态)
  
  e.wait([timeout])
    功能：如果e是未设置的状态则阻塞
          如果e是被设置状态则不阻塞
    参数：timeout 超时时间

  e.set()    将e变为被设置状态
  e.clear()  清除e的设置状态
  e.is_set() 判断当前e的状态  被设置 --> True   未设置 --> False

  示例：
    见event_test.py & thread_event.py

-线程锁 Lock
  from threading import Lock
  lock = Lock()   创建锁对象
  lock.acquire()  上锁，如果已经上锁则调用该函数阻塞，直到解锁
  lock.release()  解锁

  可以使用with
    with lock:  #上锁
        代码块
    代码块执行结束自动解锁
  示例：
    thread_lock.py
  * 要避免死锁：
    如线程1锁上了资源A，要获取到资源B才能完成对资源A的操作
    同时线程2锁上了资源B，要获取资源A才能完成对B的操作；
    这样就形成了死锁，线程1和线程2都无法执行

-python 线程的GIL问题(全局解释器锁)
  GIL:
    由于python解释器中加入了全局解释器锁，导致python解释器同一时刻
    只能解释一个线程，所以大大降低了python多线程的执行效率
  后果：
    python线程一般只能用在大量IO阻塞存在，或者高延迟的IO程序中。遇到
    阻塞时，线程会自动让出解释器。而在cpu密集型程序中，python线程效率低下
  GIL问题的官方建议：
    * 尽量使用多进程完成并发
    * 不使用c作为解释器时，没有GIL问题
    * 使用多种组合方案完成并发(IO多路复用等)
  效率测试：
    见Test/line.py & thread.py  | process.py  
    测试结果：
      单线程 CPU密集型 times: 10.219504356384277 秒   多进程 CPU密集型 times: 6.543515920639038 秒
      单线程 IO密集型 times: 7.836317300796509 秒     多进程 IO密集型 times: 5.602031946182251 秒

      多线程 CPU密集型 times: 11.53106951713562 秒
      多线程 IO密集型 times: 6.410496950149536 秒

-作业：
  1.多进程和多线程的编程特点及区别
  2.复习网络套接字使用
  3.编码思路流程

**********************************************************************************************
---------------------------- 2018年11月20日 星期二 晴  -------------------PythonNet(day8)------   

-进程和线程的区别和联系
  1.两者都是多任务编程的方式，都能够使用计算机内核，
    都是动态运行的过程，占有计算机资源。
  2.进程的创建删除消耗的资源要高于线程
  3.一个进程可以包含多个线程
  4.通信方面：进程空间独立，数据互不干扰，有专门的IPC(进程间通信方法)；
             线程使用全局变量进行通信
  5.多个线程共享进程的全局资源，资源操作往往需要同步和互斥的方法进行协调
  6.进程线程在系统中都有特有属性，如ID，代码段，命令集等。

  * 使用场景
    1.一个任务包含多个分支任务，且资源消耗少时，用线程；
    2.不同的独立任务，需要空间独立(方便资源的使用管理)，用多进程
    3.IO多时，可能选择 进程+IO多路复用。或者看通信中编码逻辑复杂程度

-课程要求：
  1.进程线程区别有哪些
  2.你是在什么情况下使用线程或者进程
  3.什么是同步互斥，你在什么情况下使用，如何使用
  4.进程间的通信方法知道哪些，有什么特点
  5.你是如何处理僵尸进程的
  6.进程池的原理是什么，怎么用。

-什么是服务器？
  1.硬件服务器：主机  集群
  2.软件服务器：编写的后端服务程序，在硬件服务器上运行，提供一定的后端服务
  
  软件服务器例：
    httpsever --> 处理http请求
    webserver --> 处理网站后端服务
    邮箱服务器 --> 邮件收发
    文件服务器 --> 文件上传下载

  架构模型： C/S   客户端服务器模型
            B/S   浏览器服务器模型

-网络通信模型
  循环模型：
    循环接收客户端请求，处理请求。同一时刻只处理一个请求，处理完毕再处理下一个
      优点：
        实现简单，占用资源少
      缺点：
        无法同时处理多个客户端请求
      适用情况：
        处理可以很快完成的任务，不需要建立并发，UDP比TCP更适合循环模型
  
  IO并发模型：
    IO多路复用  协程
      优点：
        能同时处理多个IO，资源消耗少
      缺点：
        只能监控IO时间，当多任务是CPU运算时，无法处理

  多进程多线程并发模型：
    每当有一个客户端连接则创建一个新的进程或者线程处理客户端请求
      优点：
        每个客户端可以长期占有服务器，使用多核进行IO处理或者CPU运行
      缺点：
        资源消耗较多

-多进程并发
  基于fork完成多进程并发
    1.创建套接字，绑定，监听
    2.等待接收客户端连接 accept
    3.当有客户端连接后，创建新的进程处理客户端请求
    4.原有进程继续等待客户端连接
    5.如果客户端退出，则销毁对应进程
  示例：
    fork_server.py

练习：
  ftp文件服务器
  功能：
    1.服务器分为客户端和服务端两部分，要求启动服务端可以同时有多个客户端操作
    2.客户端可以查看服务器文件库中的文件(客户端只能查看普通文件，不包含隐藏文件)
    3.客户端可以选择文件库中的文件进行下载
    4.客户端也可以上传本地文件到文件库
    5.使用print打印一定的命令提示界面
  技术要求：
    1.使用fork并发，tcp套接字
    2.查看文件列表：os.listdir([path]) 返回'文件名'列表
    3.判断普通文件：os.path.isfile(path)
      以'.'开头文件即是隐藏文件
  结构设计：
    将2,3,4三个功能封装在一个类内
  工作步骤：
    1.搭建网络
        服务端：fork_tcp并发服务器模型
        客户端：连接服务端
    2.封装类
    3.功能函数实现并测试
  见：
    ftp_sys     老师版见Ftp_Sys

作业：
  1.总结ftp server
  2.复习http协议，httpserver工作原理


**********************************************************************************************
---------------------------- 2018年11月21日 星期三 晴  -------------------PythonNet(day9)------     

-基于treading的多线程并发
  步骤：
    1.创建套接字，绑定，监听
    2.接收客户端连接
    3.创建新的线程处理客户端请求
    4.主线程继续等待其客户端连接
    5.当客户的退出时处理对应线程
  示例：
    tread_server.py
  
-自己写一个基于multiprocess的多进程并发服务器
  见multiP_server.py  (用二级子进程处理僵尸)
  老师版 multiP_server1.py (用daemon，不处理僵尸，主进程退出时系统才自动处理僵尸)

-集成模块完成多进程/线程socket并发
  python2 SocketServer
  python3 socketserver  

  功能：
    通过模块提供的不同类的组合完成多进程或者多线程的tcp/udp并发程序
  
  StreamRequestHandler     处理TCP请求
  DatagramRequestHandler   处理UDP请求

  TCPServer                创建tcpserver
  UDPServer                创建udpserver

  ForkingMixIn             创建多进程
  ForkingTCPServer         等于 ForkingMixIn + TCPServer
  ForkingUDPServer         等于 ForkingMixIn + UDPServer
  
  
  ThreadingMixIn           创建多线程
  ThreadingTCPServer       等于 ThreadingMixIn + TCPServer
  ThreadingUDPServer       等于 ThreadingMixIn + UDPServer

  使用步骤：
    1.创建服务器类，通过选择继承模块中的TCPServer或者UDPServer
      确定服务器类型，继承多进程或者多线程类确定并发类型
      class Server(ForkingMixIn,TCPServer):

    2.创建请求处理类，根据服务器类型选择继承流式套接字处理还是数据报套接字处理
      class Handler(StreamRequestHandler):
    
    3.重写处理类中的handle()方法，完成逻辑调用和事务处理：
      def handle(self):

      属性：
        self.request           连接套接字，相当于accept 返回的 c
        self.client_address    客户端地址，相当于accept 返回的 addr

    4.通过服务器类创建服务器对象，并绑定地址和处理类
      server = Server(('0.0.0.0',7777),Handler)

    5.通过服务器对象调用serve_forever()启动服务
      server.serve_forever()

    6.当客户端发起请求后，会自动调用请求处理类中handle()方法处理
  
  示例：
    (TCP)sock_server.py   (UDP)sock_server1.py

-HTTPServer v2.0
  功能: 
    1.接收客户端请求
    2.解析客户端请求
    3.组织数据，形成http响应格式
    4.将响应内容回发给客户端
  升级：
    1.基本的请求解析，根据具体请求返回具体内容
    2.采用多线程并发，可以满足多个客户端的同时访问
    3.除了获取网页之外，也可以获取一些简单数据
    4.使用类进行httpserver封装
  技术点：
    1.TCP套接字  socket多线程并发
    2.类的封装：使用类实例化对象，对象调用启动接口
    3.http请求和响应的格式
      请求：
        请求行  GET /abc.html  HTTP/1.1
        请求头 
        空行
        请求体
      响应：
        响应行 HTTP/1.1  200  OK
        响应头
        空行
        响应体
  示例：
    http_server_2_0.py


-协程
  定义：
    又叫(纤程、微线程)。
    是为非抢占式多任务产生子程序的计算机程序组件。
    协程允许不同入口点，在不同位置暂停或者开始执行，简单来说，协程就是
    可以暂停执行的函数。
  参考生成器：
    yield.py

  *yield是实现协程的基本关键字

  协程原理：
    通过记录一个函数栈的上下文(或者叫函数栈帧)，进行协程的切换调度
    当一个协程暂停时，会将上下文栈帧保存起来，在切换回来时恢复到原来的执行
    位置，从而继续执行

  协程优点：
    1.协程可同时处理多个任务
    2.协程本质是单线程，资源消耗少
    3.协程无需切换的开销，无需同步互斥
  协程缺点：
    1.无法利用计算机多核进行并行处理
  第三方模块：
    greenlet
      安装： sudo pip3 install greenlet

      g = greenlet.greenlet(func)
        功能：创建协程对象
        参数：协程函数
      g.switch()
        功能：启动协程函数
      示例：
        greenlet1.py

    gevent
      安装：sudo pip3 install gevent

      gevent.spawn(func,argv)
        功能：生成协程对象
        参数：func  协程函数
             argv   给协程函数传参
        返回值：返回协程对象

        * 主进程只有遇到gevent规定的阻塞才会触发协程
        * 当func中遇到gevent类型阻塞则会跳出
      
      gevent.joinall(list,[timeout])
        功能：阻塞等待回收协程
        参数：list      协程对象列表
              timeout  超时时间
      
      gevent.sleep(sec)
        功能：提供协程阻塞
      
      示例：
        gevent_test.py
      
      from gevent import monkey
      monkey.patch_all()
      monkey.patch_socket()
      ...

      功能：修改原有的IO阻塞行为，可以触发协程事件跳转
      * 必须在模块导入前设置
      示例：
        gevent_server.py

-作业：
  1.总结进程线程网络内容知识点
  2.复习pymysql使用
  3.看ftp和聊天室思维流程
  4.httpserver第二版

**********************************************************************************************
---------------------------- 2018年11月22日 星期四 晴  -------------------PythonNet(day10)-----

-项目练习
  电子词典
    功能说明：
      1.用户可以登录和注册
        登录凭借用户名、密码即可
        注册要求用户必须填写用户名、密码，其他内容自定
        用户名不能重复，且用户数据可以长期保存
      2.分为服务端和客户端，要求可以满足多个客户端同时登录
      3.客户端启动后即进入一级界面，功能如下
         注册、登录、退出
         * 如果注册或登录失败，返回一级界面

      4.如果用户登录成功，即可进入二级界面，功能如下
        查词  查看历史记录  注销
          查词：可以循环查词，输入单词，得到单词解释
                输入##退出查词，返回二级界面
            单词本：
              每行一个单词
              单词从小到大排列
              单词和解释之间有空格

          查看历史记录： 选择该项即可显示当前登录用户最近
                       的查词记录（可以显示所有，也可以显示最近10条）
                       格式： name  word   time 
          注销：退出登录，回到一级界面
  开展：
    1.确定技术点：
      数据库使用：mysql
      确定单词查询方案，文本或数据库
      确定套接字和并发方法
    2.建立数据库和数据表
      几个表，表的关系，表的字典，字段类型
      如果使用数据库查词，将单词插入数据库
    3.项目结构分析，分为几部分几个功能模块
    4.搭建通信模型
  
  具体功能实现：
    注册：
      客户端：
        1.输入注册信息
        2.将信息发送给服务器
        3.等待得到服务器反馈
      服务端：
        1.接收请求
        2.判断是否已存在同名用户，判断是否允许注册
        3.如果不允许注册，将判定结果返回给用户
        4.如果允许注册，将注册信息写入数据库
        5.写入成功则返回结果给用户
    查词：
      客户端：
        1.发送请求 Q name word
        2.得到反馈结果
        3.输入##退出
      服务端：
        1.接收请求
        2.查找单词
        3.反馈结果
        4.插入历史记录
    查看历史记录：
      客户端：
        1.发送请求 H name 
        2.得到反馈结果
        3.返回二级目录
      服务端：
        1.接收请求
        2.查找该用户的查询记录
        3.反馈查询结果
  cookie:
    getpass模块，隐藏输入
    pwd = getpass.getpass('请输入密码')
  
  见：
    yingyingdictionary

**********************************************************************************************
---------------------------- 2018年11月23日 星期五 晴  -------------------PythonNet(day11)----- 

-正则表达式
  动机:
    1.文本处理已经成为计算机的常见工作之一
    2.对文本内容的搜索，定位，提取是逻辑比较复杂的工作
    3.为了快速方便地解决上述问题，产生了正则表达式
  定义：
    即文本的高级匹配模式，提供搜索替换等功能。
    其本质是一系列由字符和特殊服务组成的字符串，这个字符串即正则表达式
  匹配原理：
    由普通的字符和特殊符号构成，通过描述字符的重复，位置，种类等行为，达到
    匹配某一类字符串的目的
  示例：
    re_mail.py
  正则特点：
    * 方便处理文本
    * 支持语言众多
    * 使用灵活多样
  目标：
    1.熟练掌握正则表达式符号
    2.能够读懂正则表达式，编写简单的正则表达式
    3.能够使用Python re操作正则表达式

-元字符
  1.普通字符
    元字符: a B c...
    匹配规则：每个字符匹配对应的自身字符
    例：
    re.findall('你好','你好，北京欢迎你')
      >>> ['你好']
    re.findall('ab','asdfabasdfaabbba')
      >>> ['ab', 'ab']

  2.或
    元字符： |
    匹配规则：匹配 | 两边的字符
    例：
      re.findall('ab|cd','aaaabsdfccd')
        >>> ['ab', 'cd']
    【注意】: 
      1. | 两边不要加空格，否则会认为要匹配空格
      2. findall函数匹配不到重叠的字符，如
          findall('ab|bc','abcde')
            >>>['ab']

  2. 匹配单个字符
    元字符：.
    匹配规则： 匹配除换行外任意一个字符
    例：
      f.o --> foo f*o f2o...
      f..d --> feed food ftmd...等都可以匹配到
      **在匹配方法后加re.S可以使之匹配包括\n在内的所有字符
      rList = re.findall(r'表达式',目标字符串,re.S)

  4.匹配字符串开始位置
    元字符： ^
    匹配规则：匹配目标字符串的开始位置(起始位置)
    例：
      re.findall('^Jam','Hi,Jam')
        >>>[]  #因为^代表的是字符串开始位置，所以匹配不出来结果
      re.findall('^Jam','Jam very NB')
        >>>['Jam']
  5.匹配字符串的结束位置
    元字符： $
    匹配规则：匹配弥补字符串的结束位置
    例：
      re.findall('Jam$','Jam very NB')
       >>>[]
      re.findall('Jam$','Hi,Jam')
        >>>['Jam']
  6.匹配重复
    元字符：*
    匹配规则：匹配前面的字符出现0次或多次...
    例：
      fo* --> f (o出现次)   foooooooooo 都可以匹配到
  7.匹配重复：
    元字符：+
    匹配规则：匹配前面的字符出现一次或多次
    例：
      fo*  --> fo foooo   匹配不到f
  8.匹配重复：
    元字符： ?
    匹配规则：匹配?前面的字符出现0次或1次
    例：
      re.findall('fo?','fooofffofoo')
       >>>['fo', 'f', 'f', 'fo', 'fo']
  9.匹配重复
    元字符：{n}
    匹配规则：匹配前面的字符重复指定的次数
    例：
      fo{3}  --> fooo
  10.匹配重复
    元字符：{m,n}
    匹配规则：匹配前面的字符出现m~n次(包含m/n)
    例：
    re.findall('fo{2,4}',"fooofofffoooooo")
      >>>['fooo', 'foooo']
  11.匹配字符集
    元字符：[字符集]
    匹配规则：匹配字符集中任意一个字符
    [abcd123] --> a b c 1 2 3  匹配不到ab...只能匹配一个字符
    可以指定范围：
     [a-z]  [A-Z] [0-9] [$#_a-zA-Z]
  12.匹配字符集
    元字符：[^...]
    匹配规则：匹配除指定字符外的任意一个字符

    [^abc] --> 除了a b c外任意一个字符
  13.匹配任意(非)数字字符
    元字符： \d \D
    匹配规则：
      \d 匹配任意一个数字字符  [0-9]
      \D 匹配任意一个非数字字符 [^0-9]
  14.匹配任意(非)普通字符
    元字符： \w  \W
    匹配规则：\w 匹配普通字符  (数字字母下划线，utf8字符,如:普通中文文字)
             \W 匹配非普通字符  (除以上普通字符外，如:!@#$%^&*()+-/= <空格>)
  15.匹配任意(非)空字符
    元字符：\s  \S
    匹配规则： \s  匹配任意空字符    [\r\n\t\v\f<空格>]
              \S  匹配任意非空字符
    例：
      re.findall('\w+\s+\w+','hello  world')
        >>>['hello  world']
  16.匹配字符串开头结尾位置
    元字符：\A  \Z
    匹配规则：
      \A  匹配字符串开头位置  同^
      \Z  匹配字符窗结尾位置  同$

  cookie:绝对匹配(完全匹配)
      保证正则表达式匹配目标字符串的全部内容, ^正则表达式$
      re.findall('^\d+$','1000-15000')
        >>>[]

      re.findall('^\d+-\d+$','1000-15000')
        >>>['1000-15000']
  17.匹配(非)单词边界
    元字符：\b \B
    匹配规则： \b  匹配单词边界
              \B  匹配非单词边界
    普通字符和其他字符的交界就是单词边界,字符串的开头和结尾也是单词边界
    例：
      re.findall('is','This is a boy')
        >>>['is', 'is']
      re.findall(r'\bis\b','This is a boy')
        >>>['is']

  元字符总结：
    1.匹配单个字符: 普通字符  . 字符集  \d \D \w \W \s \S
    2.匹配重复:     * + ? {n} {m,n}
    3.匹配位置:     ^ $ \A \Z \b \B
    4.其他:        | () \

  正则表达式的转义：
    正则特殊符号：. * + ? ^ $ () [] | \w
    正则表达式如果匹配特殊字符本身，则需要加\

                      正则表达式    用字符串把正则表达式传给re模块
     ex:  匹配12.34   '12\.34'     '12\\.34' 或 r'12\.34'
          匹配$10     '\$\d+'      '\\$\\d+' 或 r'\$\d+'

-贪婪和非贪婪
  贪婪模式：
    正则表达式的重复匹配默认总数尽可能多的向后匹配内容
    * + ? {m,n}
  非贪婪模式(懒惰模式)：(在重复匹配符后面加?号)
    匹配重复字符时，尽可能少地匹配内容

-正则表达式分组
  使用()可以为正则表达式内部建立分组。通过分组构建正则表达式的内部整体处理部分

  re.search(r'(ab)+','abababab').group()
    >>>'abababab'
  *子组是正则表达式的一部分，子组需要在整体能够匹配内容的前提下发挥作用
    如：pattern = r'[1-9]{1,3}(\.[0-9]{1,3}){3}'
        str1 = '127.0.0.1 192.168.1.66'
        re.findall(pattern,str1)  #子组是在整体匹配到127.0.0.1之后，才可以提取到子组匹配到的.1,
        # 如果整体没有匹配到东西，子组也是为空的

  子组的作用：
    1.作为一个内部整体，改变某些元字符的操作对象
      re.search(r'\w+@\w+.(com|cn)','abc@123.cn')  #可以匹配到
      re.search(r'\w+@\w+.com|cn','abc@123.cn')  #只能匹配到'cn',因为它认为 | 两边都是独立的内容
    2.在匹配到内容的前提下，子组对应内容可以单独提取
      re.search(r'(http|https|ftp)://\S+','https://www.baidu.com').group()
        >>>'https://www.baidu.com'

      re.search(r'(http|https|ftp)://\S+','https://www.baidu.com').group(1)
        >>>'https'

-捕获组合非捕获组
  捕获组：
    被命名的子组
    格式：(?P<组名>组内容)
    作用：名字可以表达一定的含义,也可以通过名字来提取子组对应的内容
    re.search(r'(?P<shadiao>[A-Z])\w*','Hello').group('shadiao')
      >>>'H'
    
  * 一个正则表达式中可以有多个子组，多个子组尽量不要重叠或者过多嵌套。通常
    由外到内，从左到右分为第一第二子组

    \d{10}[0-1][0-9][0-3][0-9]\d{3}(\d|X)

-正则表达式的设计原则：
  1.正确性：能够正确地匹配目标字符串
  2.排他性：除了要匹配的内容，尽可能不要匹配到其他多余内容
  3.全面性：尽可能将目标字符串的全部情况考虑全面，不遗漏

-Python --> re模块
  regex = compile(pattern,flags = 0)
    功能：生成正则表达式对象
    参数：pattern  正则表达式
          flags    功能标识，用来丰富正则表达式功能
    返回值：正则表达式对象
  
  re.findall(pattern,string,flags)
    功能：使用正则表达式匹配目标字符串
    参数：pattern  正则表达式
          string   目标字符串
          flags    标志位
    返回值：列表，匹配到的内容
           如果正则表达式有子组，则只获取子组对应内容
           re.findall(r'(\d+)','2008年发生了很多大事，08奥运，512地震等')
            >>>['2008', '08', '512']
            
  regex.findall(string[,pos,endpos])
    功能：使用正则表达式匹配目标字符串
    参数：string  目标字符串
          pos     匹配目标的起始位置,索引值
          endpos  匹配目标的结束位置,索引值，不包含
    返回值：列表，匹配到的内容
           如果正则表达式有子组，则只获取子组对应的内容

  -compile对象regex的属性
    regex.pattern    regex绑定的正则表达式
    regex.flags      功能标志位值
    regex.groupindex 字典：子组名(捕获组名)为键，子组号为值
    regex.groups     子组数量
    
  * 所有其他函数，直接用re调用，和用regex对象调用，它们的区别就跟↑↑↑findall一样，下面只展示re直接调用的方法

  re.split(pattern,string,flags)
    功能：使用正则匹配到的部分切割目标字符串
    参数：pattern    正则
          string    目标字串
          flags     标志位
    返回值：返回列表，为切割后的内容
    re.split(r'\s+','Hello world  Nihao BeiJing')
  
  re.sub(pattern,replaceStr,string,max,flags)
    功能：使用字符串替换匹配到的内容
    参数：replaceStr  替换字串
          max        最多替换几处
    返回值：返回替换后的字符串
    re.sub(r'[A-Z]\w+','Shadiao','Hello World,Nhao beijing ')
      >>> Shadiao Shadiao,Shadiao beijing
  
  re.subn()
    功能参数同sub
    返回值：返回替换后的字符串和替换数量的元组
        (Shadiao Shadiao,Shadiao beijing, 3)
  
  re.finditer(pattern,string,flags)
    功能：使用正则表达式匹配目标字符串
    参数：同上
    返回值：返回一个包含匹配内容的可迭代对象，迭代出来的结果还是对象match obj
    示例：
      regex1.py

    * 使用finditer fullmatch match search都可以生成 Match object
    * 可以使用Match object.group()方法获取Match object对应的字串
  
  re.fullmatch(pattern,string,flags)
    功能，完全匹配一个目标字符串
    参数：同上
    返回值：匹配到值则返回MATCH对象
           匹配不到返回None

  re.match(pattern,string,flags)
    功能，匹配一个目标字符串开始位置(相当于在正则表达式前加^)
    参数：同上
    返回值：匹配到值则返回MATCH对象
           匹配不到返回None      

  re.search(pattern,string,flags)
    功能：获取第一处匹配到的内容
    参数：同上
    返回值：匹配到值则返回MATCH对象
           匹配不到返回None             

-Match对象的属性和函数
  属性：
    pos        目标字串开始位置
    endpos     目标字串结束位置
    re         正则表达式
    string     目标字符串
    lastgroup  最后一组组名,如果最后一组没有组名，则为None
    lastindex  最后一组序列号
  方法：
    start()    匹配到的内容在目标字串中的开始位置
    end()      匹配到的内容在目标字串中的结束位置
    span()     元组，匹配到的内容在目标字串中的起止位置
    group(n)   获取match对象的对应内容，
               参数：默认0    表示获取match对象全部内容
                    >0的整数  表示获取该子组对应内容
                    子组名称  表示获取该子组对应内容
               返回值：返回对应字符串
    groupdict() 获取捕获组名称(key)和对应内容(value)的字典
    groups()    获取所有子组的对应内容,返回元组

  示例见 match1.py

-作业：(见re_homework.py)
  使用re模块  函数 用complie 在写一遍
  熟记元字符
  编写一个程序，匹配一个文档中
  1.所有大写字母开头的单词
  2.所有数字，数字包括
    整数  小数  分数  百分数   负数
    123   1.24 1/2   45%     -2.5

-flags参数：
  功能：re.compile re.findall re.search...等的使用参数，
       用于辅助正则表达式，丰富匹配效果
  常用选项：
  I == IGNORECASE     匹配时忽略大小写字母区分
  S == DOTALL         让.能够匹配任意字符(如果没有设置该选项，.不能匹配换行)
  M == MULTILINE      作用于元字符 ^ $,使其能匹配每一行的开头、结尾位置
  A == ASCII          使\w\W\d\D\b\B只能匹配ASCII字符
  L == LOCALE         使\w\W\d\D\b\B匹配本地字符
  U == UNICODE        使\w\W\d\D\b\B匹配UNICODE字符
  X == VERBOSE        详细模式，忽略空白，可以加入注释  r'\w+ #注释内容'

  *如果需要同时使用多个flags选项，可以用|进行按位或:  regex.findall(pattern,re.I|re.M)


**********************************************************************************************
---------------------------- 2018年11月30日 星期五 晴  -------------------PythonNet(day12)----- 

-python网络编程项目实战

-软件项目过程
  1.什么是软件项目：
    完成特定功能的软件集合
      软件产品：不针对特定用户，具有通用性，如office办公软件等
      软件项目：针对特定用户的特定需求开发的软件，如某企业的信息化管理系统
      接口（API）：函数，类，模块都可能是接口。提供的具有一定功能的代码，通过获取数据返回相应的结果

  2.软件项目管理
    1.为使软件项目获得成功，需要对软件开发的工作范围，进度，成本，质量，风险进行把控
    2.贯穿于整个软件开发过程
  3.软件开发过程
    1.指软件生命周期里，软件开发遵循的步骤
    2.软件有哪些阶段，各阶段主要任务
    3.软件生命周期包括：
      1.问题定义：弄清客户有什么问题
                 软件解决什么问题
      2.可行性研究：是否可行
      3.立项：筹备项目资源，项目正式启动
      4.需求分析：定义详细需求
      5.开发：设计，编码，测试
      6.投产：正式部署，运行
      7.维护：正常运行
      8.终止，下线
  4.各阶段的主要任务
    1.问题定义：了解客户的问题，痛点，需求-->调研报告
    2.可行性研究：
      - 经济效益或社会效益
      - 技术条件是否成熟
      - 业务，市场
      - 法律
      - 同类产品，有哪些优缺点
      结论：做还是不做
    3.立项：筹备资源，启动项目
      - 经费
      - 人员，团队，项目负责人
        (对项目成功起到关键性作用)
      - 软硬件设施
      - 场地
      - 项目详细计划(项目负责人)
        - 项目阶段，先后顺序
        - 时间轴，里程碑
        - 人员配置，分工
    4.需求分析
      - 确定项目的范围，边界(做什么，不做什么)
      - 包含哪些功能(模块),输入,输出是什么
      - 需求量化，细化
        例：支持高并发 --量化-->  每秒处理n个事务
            高可用性  --量化-->  7*24小时服务，可用率99%
      - 需求评审：评审需求描述是否正确，准确，是否有遗漏
          产出：需求规格说明书
    5.设计：
      - 概要设计：系统框架，技术路线，系统关系，交互模型
      - 详细设计：数据库设计，接口设计，类设计，逻辑流程，数据定义，错误处理
          产出：概要设计说明书，详细设计说明书
    6.实现：
      编码，自测，技术难点攻关
    7.测试：
      白盒测试：深入软件内部，执行过程进行测试
      黑盒测试：测试软件功能点是否正确
      
      测试范围：
        模块测试
        集成测试
        beta测试
      测试侧重点：
        功能测试
        性能测试
      
      产出：测试报告，功能/性能是否满足要求
    8.上线投产
      软件正式部署，投入生产运行
        - 需要哪些软硬件资源
        - 需要哪些准入条件：
            行政审批，资质
            APP上架流程，微信小程序上架流程
            网站：域名，服务器，域名备案
        - 部署步骤，演练
    9.维护：
      监控系统运行状态
      修复缺陷
      优化性能
      功能变更
      数据备份和恢复
      系统定期安全性维护
      系统定期清理，如日志压缩备份
    10.终止

-http_server_3_0
  见http_server_3_0.py    

cookie:
  $wget -d 域名  # 下载网页，打印数据交互过程

  查看端口是否已被监听(可用于监测服务器程序有没有正确启动)
  $netstat -an | grep 端口号