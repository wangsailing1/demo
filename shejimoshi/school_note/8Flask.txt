**********************************************************************************************
---------------------------- 2018年12月24日 星期一 晴  -------Flask--------PythonWeb(day01)-----
老师:赵旭

-主要内容
  Flask  轻量级的WEB框架
  AJAX   在WEB中完成异步的请求和响应
  Django 重量级的WEB框架

-静态网页 和 动态网页
  1.静态网页:
    无法与服务器进行数据交互的网页
  2.动态网页：
    允许与服务器进行数据交互的网页

-WEB与服务器
  1.web: 网页(HTML,CSS,JS)
  2.服务器(web server):  能够给用户提供服务的机器就是服务器
    1.硬件和软件
      硬件:一台计算机
      软件:一个能够接受用户请求，并给出响应的程序
        1.作用
          1.存储WEB的信息
          2.能够处理用户的请求(request)和响应(response)
          3.执行服务器端的处理程序
          4.具备最基本的安全功能
        2.常用服务器端软件
          1.Apache
          2.Tomcat
          3.IIS(Internet Information Service)
          4.Nginx

-框架
  1.什么是框架
    框架是一个为了解决开放性问题而存在的一种程序结构
    框架的本身提供了最基本的功能
    我们只需要在框架的基础功能上搭建直接的操作就可以了      
  2.Python web 框架
    1.Flask - 轻量级
    2.Webpy - 轻量级(少用)    
    3.Tornado - 异步框架(少用)
    4.Django - 重量级
  3.框架模式
    1.MTV框架模式(Flask,Django)(又叫三层架构)
      M: Models层,模型层,负责与数据库打交道
      T: Template层,模板层,处理用户显示的内容,如html
      V: Views层,视图层,处理与用户打交道的内容(请求和响应)
    2.MVC框架模式
      M: Models层,模型层,负责与数据库打交道
      V: Views层,视图层,处理用户显示的内容,如html
      C: Controller层,控制器层,处理与用户打交道的内容(请求和响应)

-Flask
  1.什么是Flask
    Flask是一个基于Python并且依赖于Jinja2模板引擎和
    Werkzeug WSGI服务的一个微型框架
    WSGI : Web Server Gateway Interface(WEB服务网关接口)
    Flask是基于MTV框架模式开发出来的框架
  2.安装Flask
    1.查看已安装的Flask版本
      在python的交互模式中
      1.import flask
      2.flask.__version__
    2.安装Flask
      sudo pip3 install flask
      或者用
      pip3 download flask 该命令会把flask和相关依赖包下载下来
  3.初始化Flask应用
    见day01/FlaskDemo01/run01
      from flask import Flask
      # 将当前运行的主程序构建成Flask的应用,以便接收用户请求并给出响应
      app = Flask(__name__)

      # 定义访问路由
      @app.route('/')
      def index():
          # index()表示匹配访问路由后的处理程序-视图函数
          # 所有视图函数必须有一个return表示响应的内容
          return "This is my first flask demo"

      if __name__ == '__main__':
          # 启动flask服务,默认监听5000端口
          app.run(debug=True)   # app.run(debug=True,port=3333) 指定端口

  **cookie:
    flask默认监听5000端口
    1.查看占用5000端口的进程
      netstat -lptu(lptu是netstat的选项，用netstat -help查看全部选项)
    2.杀掉对应进程
      sudo kill -9 进程ID
  练习：(见day01/FlaskDemo01/run02)
    1.访问路径是 http://localhost:5000/login时
      在网页中显示:欢迎来到登录页面
    2.访问路径是 http://localhost:5000/register时
      在网页中显示:欢迎来到注册页面

-Flask -路由(route)
  1.什么是路由
    处理url和函数之间的关系的程序就是"路由"
  2.路由的体现
    在Flask中,路由是通过@app.route装饰器来表示的
    1.路由的基本体现
      如:
        访问路径 http://localhost:5000/admin/login
      体现:
        @app.route("/admin/login")
        def admin_login():
            return 'xxxx'
    2.带参数的路由
      路由中可以携带参数来表示不同的数据
      http://localhost:5000/show/wangwc
      http://localhost:5000/show/gebilaowang
      http://localhost:5000/show/chaogege
      http://localhost:5000/show/xxx
      
      1.基本的带参路由
        @app.route('/show/<name>')  # 形参必须用<>括起
        def show(name):
            #name参数表示的就是由地址栏上传递进来的数据
            pass
      2.带多个参数的路由(使用'/'分隔)
        @app.route('/show/<name>/<age>')
        def show(name,age):
            pass
      3.指定参数类型的路由
        使用 类型转换器 解决参数类型的问题
        @app.route('/show/<name>/<int:age>')
        def show():
            print(type(name))  # str
            print(type(age))   # int
        Flask中所支持的类型转换器
          类型转换器      作用
          缺省          字符串(不能有斜杠'/')
          int:          整型
          float:        浮点型
          path:         字符串(通常用来表示路径,允许有斜杠'/')

      4.多 URL 的路由匹配
        如:
          http://localhost:5000/  和  http://localhost:5000/index
          都访问index()

        @app.route('/地址1')
        @app.route('/地址1')
        ...
        def index():
            return ''

      示例：
        见day01/FlaskDemo01/run02
      练习：(见day01/FlaskDemo01/run02)
        1.http://localhost:5000/calc/数字1/数字2
          根据以上的访问路径制定路由，返回两个数字的和显示在浏览器上
        2.http://localhost:5000
          http://localhost:5000/index
          http://localhost:5000/数字
          httP://localhost:5000/index/数字
          都交给index_view()去处理,判断路由中到底有没有数字传递进来:
            如果有:
              响应:您当前看的页数为 10
            如果没有:
              响应:您当前看的页数为 1
  3.路由中设置允许接收的HTTP请求方法
    所有路由默认只接受GET请求,不接受POST请求
    设置请求方法:
      @app.route('/xxx',methods=['POST','GET'])  # 要求请求方法全部大写
    
    示例：见day01/FlaskDemo01/run03

  4.URL 的反向解析
    正向解析: 
      程序自动解析,会根据访问路径(@app.route('xxx')),自动来匹配处理函数
    反向解析:
      通过视图处理函数的名称自动生成对应的访问路径
    在Flask中,要实现反向解析的话，需要使用:
      from flask import url_for
      url_for(funName,args)
        funName : 要生成地址所对应的函数名
        args :    该地址中要用的参数

    示例：见day01/FlaskDemo01/run03
  
  练习：(见project/blog0.1)
    1.创建一个Flask项目 - Blog
    2.在Blog中,创建run.py 启动文件
    3.在run.py中搭建好Flask程序结构
    4.定义如下访问路径,并给出响应
      1.http://localhost:5000
        响应:这是blog的首页
      2.http://localhost:5000/list
        响应:这是blog的列表页
      3.http://localhost:5000/release
        响应:这是blog的发表页
      4.http://localhost:5000/info/<id>
        响应:查看id为xxx的blog信息
      
**********************************************************************************************
---------------------------- 2018年12月25日 星期二 晴  -------Flask-------PythonWeb(day02)-----    
-模板 - Template
  1.什么是模板
    模板，在flask中就是允许给用户看的网页，动静结合的
      动:允许包含服务器端的动态内容，如:变量,标签,过滤器
      静:纯HTML,CSS以及JavaScript的内容
    
    在Flask中，模板是依赖于Jinjia2的模板引擎
    jinja官网: http://jinja.pocoo.org
  2.模板的设置
    默认情况下,Flask会在启动程序的主文件夹中会搜索一个templates的目录来作为
    模板的存放位置
    
    需要手动创建一个templates目录，并将所有的模板文件(html)都存放进去
  3.模板的渲染
    作用：在视图中，将模板文件(**.html)先变成字符串，再响应给浏览器
    语法：
      from flask import render_template
      str = render_template('xxx.html')
      #在处理函数中返回该 str 即可
        return str
    示例：
    见day02/run01.py

  4.模板中的语法(重点)
    1.变量
      变量是一种特殊的占位符，告诉模板引擎，该位置的值是从
      渲染模板时的哪个数据中获取出来的
      语法：
        1.在视图中
          @app.route('/xxx')
          def xxx():
            return render_template('xxx.html',变量1=值1,变量2=值2,...)
        2.在模板中
          {{变量名}}
      **1.允许传递到模板中作为变量的数据类型
          字符串，整数，小数，列表，元组，字典，对象
        2.用params = locals() 可以将视图函数中的所有局部变量传递到模板中的params
          (模板中params不用声明，直接使用，为类字典类型，key为变量名,value为变量值)

      练习：(见day02/run02.py)
        创建 /03-template 路由，能够渲染 03-template.html模板，并在
        模板中输出以下内容：
          歌名 : <<绿光>>
          作词 : 宝强
          作曲 : 乃亮
          演唱 : 羽凡
    2.过滤器
      1.什么是过滤器
        在变量输出前，允许修改变量的值，再进行输出
      **到Jinjia官网中查看documentation --> fillter --> builtin fillter list
      2.语法
        {{变量|过滤器(参数)}}
        常用过滤器:
          capitalize            首字符变大写，其他变小写
          lower                 将值转换为小写
          upper                 将值转换为大写
          title                 将值中的每个单词首字符变大写
          trim                  去掉值两端的空格
          default('xx')         如果变量不存在，将采用default的值作为默认输出
          truncate(num[, bool]) 截取指定num长度的字符串,后面用...显示
                                bool值默认为false,表示包括...总共输出num个字符(当取值取不完一个单词时，该单词整体不输出)
                                bool值默设置为true,表示包括...总共输出num个字符(当取值取不完一个单词时，取到多少个字符就输出多少个)
    3.标签
      1.什么是标签
        在模板中，标签是属于服务器端内容
        每个标签表示的是不同的服务器端的功能
      2.常用标签
        1. if 标签
          1.基本if标签
            {% if 条件 %}
                if条件为真的时候，要执行的内容
                允许是静态内容，也允许是动态内容
            {% endif %} 
          2.if ... else 结构
            {% if 条件%}
              ...
            {% else %}
              ...
            {% endif %}
          3.if ... elif ... elif ... [else] 结构
            {% if 条件%}
              ...
            {% elif %}
              ...
            {% else %}  //可选
              ...
            {% endif %}
        2.for 标签
          {% for 变量 in 可迭代对象 %}
            允许出现静态内容:html,css,JS
            允许出现动态内容:
              变量{{}}
              标签{% %}  
          {% endfor %}   
          示例：
            {% for u in users %}  //users为运行程序传递过来的变量,不用提前定义,在这里直接使用
              <tr>
                  <td>{{u.id}}</td>
                  <td>{{u.uname}}</td>
                  <td>{{u.uage}}</td>
                  <td>{{u.uemail}}</td>
                  <td>
                      <a href="">删除</a>
                      <a href="">修改</a>
                  </td>
              </tr>
            {% endfor %} 
          
          循环的内部变量 - loop
            loop的作用：
              能够记载当前循环的一些相关信息
              loop 常用属性:
                index           记录当前循环的次数,从1开始记录
                index0          同上,从0开始记录
                first           判断本次循环是否是第一次循环，值:True/False
                last            判断本次循环是否为最后一次循环,值:True/False
        
        示例：day02/templates/04-var.html 

        3.macro 标签(宏)
          1.作用
            相当于是在模板中声明函数
          2.语法
            {% macro 宏名(参数列表) %}
            {% endmacro %}
          示例：day02/templates/05-macro.html
          3.在独立的模板文件中声明宏，集中管理
            1.创建一个模板文件 xxx.html  通常叫 macro.html
              作用：定义项目中要用到的所有的宏
            2.在使用的网页中导入 macro.html
              {% import 'macro.html' as macros %}

        4.include 标签
          将其他的模板文件包含到当前模板文件中
          语法：{% include 'xxx.html' %}
          示例：day02/templates/header.html                                             

      示例：见day02/run02.py
  
  5.静态文件的处理
    1.什么是静态文件
      在Flask中,不能与服务器做动态交互的文件称为静态文件,
       如:图片,css,js,音视频,文档
    2.静态文件的处理
      1.所有的静态文件必须放在static目录中
        static目录必须放在项目的根目录处
      2.所有的静态文件必须通过 /static路径进行访问
        /static : 要到静态资源目录中进一步的搜索文件
    3.静态文件地址的反向解析
      根据静态文件的具体路径，生成静态访问路径
        语法:
          url_for('static',filename='file_path')
        ex:
          url_res = url_for('static',filename='images/a.jpg')
          url_res : /static/images/a.jpg
      示例见:
        day03/run01.py | 01-url.html
        
  作业：(见project/blog0.2)
    搭建blog项目中的模板以及静态文件环境
    实现以下功能:
      1.将所有的html页面导入到blog项目中
      2.将所有静态文件(css,js,图片)导入到blog项目中
      3.在模板中要处理好所有的静态文件
        1.首页 /
          访问时，能够显示index.html中的内容
        2.列表页 /list
          访问时,能够显示 list.html 中的内容
        3.发布页 /release
          访问时，能够显示 release.html 中的内容
        4.详情页 /info/id
          访问时,能够先info.html 中的内容
  **注释含有服务器端的内容时，用{# 注释内容 #}

**********************************************************************************************
---------------------------- 2018年12月26日 星期三 晴  ------Flask--------PythonWeb(day03)----- 
-模板的继承
  1.语法
    1.父模板中
      需要定义出哪些东西在子模板中可以被重写
      {% block 块名 %}
        在父模板中可以正常显示的内容
      {% endblock %}
      block：
        1.在父模板中可以正常显示，没有任何影响
        2.在子模板中可以被重写
    2.子模板中
      1.指定需要继承自哪个父模板
        {% extends '父模板名称' %}
      2.按需重写
        {% block 块名 %}
          此处编写的内容会覆盖掉父模板中同名block的内容
          允许通过{{super()}}来调用父模板中的内容
        {% endblock %}
    见day03/templates/02-parent.html | 03-child.html

-修改配置
  1.构建Flask允许指定的配置信息
    app = Flask(__name__ [,template_folder='xxx', static_folder='xxx', static_url_path='/xxx'])
    参数说明:
      template_folder          指定存放模板的文件夹的名称
      static_folder            指定存放静态文件资源的文件夹的名称
                               注意：如果没有指定static_url_path的话，
                                    则访问路径和static_folder的名称是一致的
      static_url_path          指定静态文件的访问路径
      
  2.启动程序的运行配置    
    app.run(debug=True,port=端口号,host='0.0.0.0')

-请求(request)和响应(response)    
  1.HTTP协议
    HTTP: Hyper Text Transfer Protocal
    作用: 规范了数据是如何打包以及传递的
    
    1.通用消息
    2.请求消息
      1.请求起始行(请求行)
        1.请求方式 GET/POST
        2.请求协议 HTTP/HTTPS
        3.协议版本 1.1
      2.请求消息头(请求头)
        表达客户端浏览器要传递给服务的信息
        由 key:value 的形式组成
        每个消息头会传递不同的信息给服务
      3.请求体(请求体)
        伴随着请求要传递给服务器端的信息就是请求体
        只有post和put请求是有请求体的，其他请求方式没有请求体
      ** 2和3之间有一个空行
    3.响应消息
      作用:将服务器端的消息传递给浏览器
      1.响应起始行
        1.协议以及版本号 : HTTP/1.1
        2.响应状态码 : 200/404/500
          1xx : 请求已收到,继续处理
          2xx : 请求成功接收
          3xx : 该请求需要进一步处理
            301 - 永久性重定向
            302 - 临时性重定向
            304 - 无修改,从缓存中提取数据
          4xx : 资源不存在或无权限
            404 - 请求资源不存在
            403 - Forbbiden
            405 - Method Not Allowed
          5xx : 服务器端处理请求失败
            500 - Interneral Server Error
        3.原因短句
          以简短的英文单词解析响应状态码
          200 : OK
          404 : Not Found
      2.响应消息头
        以 key:value 的形式存在，要传递给浏览器的一些说明信息
          ex:
            Content-type : application / javascript
            Content-type 作用: 告诉浏览器响应回来的数据的类型
      3.响应主体
  2.请求对象 - request
    request - 请求对象,封装了所有与请求相关的信息.如请求数据，请求消息头...

    在Flask中,要使用request的话，必须先导入
    from flask import request

    1.request对象的常用属性
      1. scheme  :  获取请求协议
      2. method  :  获取本次请求的请求方式(GET/POST)，返回字符串
      3. args    :  获取以GET请求方式提交的数据，返回类字典，可以直接按照字典的方式来操作数据
      4. form    :  获取以POST请求方式提交的数据，返回类字典，可以直接按照字典的方式来操作数据
      5. cookies :  获取cookies的相关信息
      6. headers :  请求头信息,常用request.headers['Referer']获取原地址,'从哪来回哪去'
                    常见业务逻辑:从哪来回哪去,不知道哪来回主页 url = request.headers.get("Referer",'/')
    2.获取请求提交的数据
      1. GET请求方式
        1.地址栏上手动提交的数据
        2.form表单中使用GET方式提交
        3.使用location.href="http://127.0.0.1:5000/?name=abc&age=30"
        ex:
          name = request.args['name']
          age = request.args.get('age')
          return "姓名:%s,年龄:%s" % (name,age)
      2. post请求方式
        只有表单中设置method为post才能产生post请求
        request.form 获取的就是以post方式请求提交过来的数据
          request.form['控件的name值']
          request.form.get('控件的name值')
cookie:
  请求重定向
    重定向：
      在服务器端，指定重新向一个路由发送请求
    用法:
      from flask import redirect
      在视图函数中：
        retrun redirect('/03-queryall')

  作业:(project/blog0.2)
    1. 处理Blog中的登录 - login
      1.如果是get请求,则渲染login.html到浏览器
      2.如果是post请求,则接收所有的请求数据,并响应给浏览器
    2. 处理Blog中的注册 - register
      1.如果是get请求，渲染register.html到浏览器
      2.如果是post请求,接收所有的数据响应给浏览器

**********************************************************************************************
---------------------------- 2018年12月27日 星期四 晴  ------Flask--------PythonWeb(day04)----- 
-请求和响应
  1.文件上传
    1.注意问题
      表单中如果有文件上传的时候，必须遵循以下两个要求
      1.提交方式 method 必须为 post
      2.表单的 enctype 属性值必须为 multipart/form-data
    2.服务器端处理
      1.request.files 获取上传的文件，同样是类字典数据，
        f = request.files['文件框的name值']
        注意:
          获取到的文件对象f是保存在缓存区的，并非保存在磁盘上，因此要手动写入磁盘
      2.将文件保存到指定目录
        f.save('static/文件名')
        f.save()的参数：
          1. 'static/' 表示存储到运行程序的相对路径中static文件夹下
          2. 如果需要使用原文件名：'static/'+f.filename
          3. 如果需要存入绝对路径,也可以写绝对路径
      3.问题解决
        1.文件名称(避免同名文件覆盖)
          1.用时间来命名
            年月日时分秒微妙.扩展名
            1.获取时间
              import datetime
              ftime = datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")
            2.获取扩展名
              ext = f.filename.split('.')[-1]
            3.组合成存储文件名
              fname = ftime + '.' + ext
        2.保存路径
          # 获取运行程序的绝对路径
          basedir = os.path.dirname(os.path.abspath(__file__))
          # 拼成保存地址
          upload_path = os.path.join(basedir,'static/upload',fname)
          
          ##cookie:
            os.path.dirname(__file__)返回脚本的路径，但是需要注意一下几点:
            1.必须是实际存在的.py文件，如果在命令行执行，则会引发异常NameError: name '__file__' is not defined；
            2.在运行的时候如果输入完整的执行的路径，则返回.py文件的全路径如：Python c:/test/test.py 
              则返回路径 c:/test ，如果是python test.py 则返回空；
            3.结合os.path.abspath用，效果会好，如果大家看过一些python架构的代码的话，会发现经常有这样的组合：
              os.path.dirname(os.path.abspath(__file__)),os.path.abspath(__file__)返回的是.py文件的绝对路径。
            这就是os.path.dirname(__file__)的用法，其主要总结起来有:
              不要在命令行的形式来进行os.path.dirname(__file__)这种形式来使用这个函数；
              结合os.path.abspath()使用
          
        2.保存路径
        示例：
          day04/ 01-file.html
  2.模型 - Models层
    1.什么是模型
      模型，是根据数据库中表的结构而创建出来的class
      每张表对应到编程语言中就是一个类
      类中的每个属性对应到表中就是表的一个字段
    2.模型框架 - ORM
      1.什么是ORM
        ORM: Object Relational Mapping
              对象      关系      映射
      2.ORM的三大特征
        1.数据表到编程类的映射(table <--> class)
          数据库中每一张表对应到编程语言中都有一个类
        2.数据类型的映射
          数据库表中的字段以及数据类型，对应到类中也会有对应的属性和类型
        3.关系的映射
          将数据库表与表之间的关系，对应到编程语言中类与类之间的关系
      3.ORM的优点
        1.封装了数据库中几乎所有的操作，大大提高开发效率
        2.省略了庞大的数据访问层，即便不使用SQL语句也能完成对数据CRUD操作
    3.Flask中的ORM框架
      Python中的ORM框架 - SQLALchemy
        pip3 install sqlalchemy
      Flask中使用的也是SQLAlchemy,但中间需要使用Flask-SQLALchemy 连接 Flask 和 SQLALchemy
        pip3 instal flask-sqlalchemy
    4.定义数据库 以及 连接数据库
      1.创建数据库
        create database 数据库名 default charset utf8 collate utf8_general_ci;
        collate: 数据排序和校对规则
          取  utf8_general_ci  忽略大小写
          取  utf8_general_cs  区分大小写
        推荐数据库工具:
          1.Navicate for MySQL
          2.Power Designer
      2.Flask中连接数据库
        from flask_sqlalchemy import SQLAlchemy
        app = Flask(__name__)
        # 指定数据库的配置给 app
        app.config['SQLALCHEMY_DATABASE_URI'] = "mysql://root:123456@localhost:3306/数据库名"

        #再将app交给SQLAlchemy创建数据库实例
        db = SQLALchemy(app)
        或 
        db = SQLAlchemy()
        db.init_app(app)

        #以后在Flask中操作数据库就可以用db
      
    5.定义模型(重点)
      模型: 类(模型类 或 实体类)
      语法:
        class 模型类名(db.Models)
            __tablename__ = "表名"  # 表示该类映射到哪张表
            字段名1 = db.Column(db.数据类型,选项)
            字段名2 = db.Column(db.数据类型,选项)
            字段名3 = db.Column(db.数据类型,选项)
            ...                                       # 一个COLUM_NAME代表该表中的一个字段

        1.模型类名自定义，建议参考要映射到的表名
        2.字段名要与表中已存在的字段名一致，表中不存在该字段名时，会自动创建
        3.选项: 列选项，如： 是否唯一，默认值，是否加主键、索引等...
            
        db.数据类型：
            类型名           对应mysql类型          说明
          db.Integer         int                普通整数,4字节
          db.SmallInteger    samllint           小整数，2字节 
          db.BigInteger      bigint             不限精度整数
          db.Float           float              浮点数
          db.Numeric         deciaml/Decimal    定点数
          db.String(长度)    char               字符串
          db.Text            text               字符串(长文本)
          db.Boolean         tinyint(0/1)       布尔值
          db.Date            date               日期:年月日
          db.Time            time               时间:时分秒
          db.DateTime        datetime           日期时间:年月日时分秒
        
        列选项:
          选项名             说明
        autoincrement      设置为True表示该列自增长
        primary_key        设置为True表示该列为主键
        unique             设置为True表示该列的值唯一
        index              设置为True表示该列创建索引
        nullable           如果设置为True表示该列允许为空(默认为False不允许为空) 
        default            为列指定默认值
      示例：
        创建字段:id,设置主键、自增
        id = db.Column(db.Integer,primary_key=True,autoincrement=True)

      2.将创建好的实体类映射到实体库
        db.create_all()
    实例:创建表day04/run01.py  使用day01/run02.py
    ## cookie:
      # 为flask的程序实例制定SQLALCHEMY_TRACK_MODIFICATIONS
        app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False //通常设置为False,设置为True会追踪操作，占用内存 

    练习:(day04/run03.py)
      1.创建Student实体类
        表名:student
        属性：
          1.id: 主键、自增
          2.sname : 姓名，长度为30的字符串
          3.sage : 年龄，整数
          4.isActive: 启用状态,默认True
      2.创建Teacher实体类
        表名:teacher
        属性:
          1.id : 主键、自增
          2.tname: 姓名、长度为30字符串
          3.tage: 年龄,整数
      3.创建Course实体类
        表名:course
        属性:
          1.id : 自增、主键
          2.cname: 课程名称，长度为50的字符串，允许为空
  作业:
    1.创建数据库 Blog
    2.分析login 以及 register 的业务，并得出用户实体类
    3.根据分析出来的用户实体，创建实体类(属性),并映射回数据库    

**********************************************************************************************
---------------------------- 2018年12月28日 星期五 晴  ------Flask--------PythonWeb(day05)----- 
1.模型类的映射管理
  1.什么是映射管理
    对模型类/实体类的修改允许再映射回数据库
  2.依托于第三方库完成管理
    1.flask-script
      pip3 install flask-script
      包：flask_script
      类:Manager
        作用:可以对项目进行管理,如:启动项目，添加命令
      **注意:
        # 通过manager管理启动程序时
          manager.run()
        要开启debug，则在程序中：app.config['DEBUG'] = True
        要绑定host为0.0.0.0:
          在终端启动时以参数传入:
            python3 run.py runserver --host 0.0.0.0 --port 6666
      
    2.flask-migrate   
      pip3 install flask-migrate
      包：flask_migrate
      类：
        1.Migrate
          作用：用于管理app和db之间的协调关系
        2.MigrateCommand
          作用：允许在终端中提供实体类迁移的命令

    3.实现数据库的迁移
      1.python3 run.py db init 
        作用: 做一些初始化的行为操作
        特点: 一个项目中只需执行一次就可以了
      2.python3 run.py db migrate
        作用: 将编写好的实体类生成中间文件
        特点: 检测实体类是否有修改，如有修改，则生成中间文件
      3.python3 run.py db upgrade
        作用: 将中间文件映射回数据库

2.ORM中的CRUD
  1.增加 - C(Create)
    1.创建实体对象，并为实体赋值
      user = User()
      user.uname = 'wangwc'
    2.将实体对象增加回数据库
      db.session.add(实体对象)
      # 针对非查询操作,必须手动提交回数据库
      db.session.commit() 
      **# 配置操作自动提交
        配置成功后,会在执行完视图函数之后，整体将行为提交回数据库
        app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = True
  2.查询 - R(Retrieve)
    1. 基于 db.session 进行查询
      1. db.session.query()
        该函数会返回一个Query对象，类型为BaseQuery
        该返回值会中会包含针对某个实体或实体中的列所有的查询操作
        语法：
          1. db.session.query(实体类)
              查询对应实体类中所有列的数据
            ex:
              db.session.query(User)
              等同于 select * from user
          2.db.session.query(实体类.属性1,实体类.属性2)
            查询对应实体类中部分列的数据
            ex:
              db.session.query(User.id,User.uname)
      2.查询执行函数
        目的：在query()的基础上得到最终的数据
        语法: db.session.query(xxx).查询执行函数()
          函数                说明
        all()               以列表的方式返回query()中包含所有数据的实体对象，取对象的属性即可得到对应字段值
        first()             以实体对象的方式返回query()中的第一条数据,如果没有结果，则返回None
        first_or_404()      效果同上,如果查询不到数据,则响应404
        count()             查询共有多少条记录，返回整数
      3.查询过滤器函数
        作用: 在db.session.query()的基础上，进行条件筛选
        语法: db.session.query().查询过滤器函数().查询执行函数()
        查询过滤器:
            函数                 说明
          filter()            按指定条件进行过滤
          filter_by()         按等值条件过滤时使用
          limit()              获取前几行数据
          order_by()           排序
          group_by()           分组
        过滤器函数的详解
        1.filetr()
          作用：实现查询中的各种条件
          注意：条件必须由 实体类.属性 构成
          1.查询年龄大于17的user信息
            db.session.query(User).filter(User.uage>17).all()
          2.查询年龄大于17且id大于1的user的信息
            db.session.query(User).filter(User.uage>17,User.id>1).all()
          3.查询年龄大于17或者id大于1的user信息
            注意:查询 或 的操作,要借助于 or_() //要先from sqlalchemy import or_
            用法:or_(条件1,条件2)
              db.session.query().fillter(or_(xxx,xxx)).all()
          4.查询id的值为2的user信息
            注意:等值判断要用==
              db.session.query().filter(User.id==2).first()
          5.查询uemail中包含 w 的user信息
            注意：模糊查询like需要使用实体类的属性所提供的like()完成查询
              db.session.query(User).filter(User.uemail.like('%w%')).all()
          6.模糊查询 - in
            注意：模糊查询in需要使用实体类的属性所提供的in_()完成查询
              db.session.query(User).filter(User.uage,in_([15,17,19])).all()
          7.模糊查询 - between and
            注意:模糊查询between and 需要使用实体类的属性所提供的between(值1,值2)完成查询
              db.session.query(User).filter(User.uage.between(13,15)).all()
        2.filter_by
          作用: 只做等值条件筛选过滤，并且只能用于单表查询
          特点：
            1. 不用 实体类.属性名,直接使用属性名即可
            2. 不用 == , 用 =
          ex:
            db.session.query(User).filter_by(id=1).first()
        3.limit()
          作用：获取前几行数据
          语法：db.session.query(User).limit(num)
          ex:
            db.session.query(User).limit(1).all()
            db.session.query().filter().limit().offset()
          **使用 offset() 可以完成数据的偏移
            db.session.query(User).limit(2).offset(3).all()
            跳过前3条数据，再获取剩余的前2条数据
        4.排序 order_by()
          1.user表中的数据按id降序排序
            db.session.query(User).order_by("id desc")
          2.user表中的数据按年龄升序排序,年龄相同的按id降序排序(二级排序)
            db.session.query(User).order_by("age asc, id desc")
      示例：day05/run01.py
      练习：见(day05/run01.py)
        1.访问路径 /03-queryall
        2.能够渲染 03-queryall.html 模板
        3.在模板中显示
          用表格显示以下内容
          id  姓名    年龄    邮箱          操作
          1   wangwc   16   xxx@163.com  删除  修改
          ...
        4.点击"修改"时,将要修改的人的信息显示在04-update.html
          姓名 : [xxx]        //[代表输入框],<代表按钮>
          年龄 : [xxx]
          邮箱 : [xxx]
          <修改>
        5.点击4中的<修改>按钮将数据更新到数据库
        6.点击3中的删除按钮，弹出确认框，点击确认则删除该条信息
           
    2. 基于 实体类 进行查询
           
**********************************************************************************************
---------------------------- 2018年12月29日 星期六 晴  ------Flask--------PythonWeb(day06)----- 
1.查询 - R
  1.聚合查询
    from sqlalchemy import func  # func对象中提供了所有的聚合函数
    db.session.query(func.聚合函数(实体类.属性)).all()
      聚合函数:
        sum()   :  求和
        count() :  求非空的数量
        max()   :  求最大值
        min()   :  求最小值
        avg()   :  求平均值
    ex:  查询user表中所有人的平均年龄(uage)是多少
      db.session.query(func.avg(User.uage)).first()
  2.分组
    db.session.query(聚合).group_by('属性名').all()           
    // 返回列表，列表中嵌套元组，一个元组就是一条记录，里面包含对应字段值
    示例:day06/run01.py
    练习：(day06/run01.py)
      1.为User实体类增加一个属性 isActive(为user表增加一个列isActive),默认为True
      2.到数据库中随意修改几条数据的isActive的值为False
      3.在程序中实现，统计被激活的用户数量以及未被激活的用户数量分别是多少并打印输出
  3.带条件的分组聚合
    db.session.query(聚合).filter(条件).group_by('字段名').having(分组后的条件).all()
    ex:
      在user表中要统计大于16岁的用户的激活人数和未激活人数，并输出大于两人的信息
      db.session.query(func.count(User.isActive)).filter(
        User.uage>16).group_by('isActive').having(func.count(User.isActive)>2).all()
  
  2.基于实体类进行查询(只能单表查询)
    实体类.query.查询过滤器函数(条件函数).查询执行函数()
    ex: 查询user表中所有数据
      1.使用db.session
        db.session.query(User).all()
      2.使用 实体类
        User.query.all()

2.修改 - U
  1.查
    将要修改的实体对象查询出来
  2.改
    通过实体对象.属性 = 值
  3.保存
    db.session.add(实体对象)  
  示例：
    day06/run01.pu  "/06-update"      

3.删除 - D
  1.查
    查询出要删除的实体对象
  2.删    
    db.session.delete(要删除的实体对象)

4.关系映射
  1.一对多
    1.什么是一对多
      A表中的一条数据能够关联到B表中的多条数据
      B表中的一条数据能够关联到A表中的一条数据
      ex:
        1.博客系统中的用户与发表的文章
          一个用户允许发表多篇文章
          一篇文章对应一个用户
    2.一对多在数据库中的实现
      依托于 主外键 关系创建
    3.在Flask-SQLAlchemy 上的实现
      在"多"的实体类中增加对"一"的实体类的引用
      1.在"多"实体类中:
        增加一个列(外键列),引用自"一"类的主键对应字段
          外键列名=db.Column(db.Integer,db.ForeignKey("参考表名.主键列"))
      2.在"一"的实体类中:
        增加 关联属性 以及 反向引用关系属性(难点)
        1.关联属性
          在"一"的实体中，要通过哪个<<属性>>来获取到对应的所有的"多"的实体对象们
          ex: 在博客系统中，用户实体通过哪个属性来获取到他发表的所有文章实体对象
        2.反向引用关系属性:
          在"多"的实体中，要通过哪个<<属性>>来获取对应的"一"的实体对象(该属性要写在"一"的实体类中)
          ex: 在博客系统中，一篇文章实体通过哪个属性来获取到该文章对应的发表者
        语法：
          属性名=db.relationship("多_实体类名",backref="反向引用关系属性名称",lazy="dynamic")
          ** lazy参数: 表示延时加载，指定如何加载关联数据
              取值:
                1.dynamic      动态加载，什么时候用数据，什么时候加载(最常用)
                2.select       在首次访问时,加载关联记录
                3.immediate    源对象使用后,马上加载关联数据
                4.subquery     效果同上,但是会使用子查询的方式加载关联数据
                5.noload       永不加载
                
          ex：
          class User(db.Model):
              xxx
              article = db.relationship('Article',backref="user",lazy="dynamic")
          
          class Article(db.Model):
              xxx
              user_id = db.Column(db.Integer,db.ForeignKey("user.id"))
          **使用时:
            user = User.query.filter_by(id=1)

            # 获取user发表的全部文章实体对象
            user_art = user.article.all()

            article = Article.query.filter_by(id=1)

            # 获取该篇文章对应的发表者实体对象
            article_user = article.user.all()   
    练习:(day06/run01.py / 09-regteacher --> 09-regteacher.html)  
      点击注册添加老师信息到数据库,课程用下拉列表做
    练习2:(day06/run01.py / 11-showteachers --> 11showteachers.html)
      1.下拉列表(实现按课程筛选显示老师信息)
          所教课程
          项1: 全部
          项2: Python基础...
          ...
      2.表格:(显示老师信息)
        老师姓名  老师年龄  所教课程
        
  2.一对一
    1.什么是一对一
      A表中的一条记录只能与B表中的一条记录相关联
      B表中的一条记录只能与A表中的一条记录相关联
    2.在数据库中的体现
      外键关联,唯一约束
    3.在实体类中的体现
      1.在任意一个类中增加外键和唯一约束
        外键列名=db.Column(db.Integer,db.ForeignKey('主表.主键列'),unique=True)
      2.在另外一个类中增加 关联属性 和 反向引用关系属性
        关联属性 = db.relationship('关联是实体类',backref="反向引用属性",uselist=False)

        ** uselist : 该属性将使用标量来表示,而不是列表
    练习:(day06/run01.py /13-queryuser --> 13-queryuser.html)
      模糊查询  输入任意字符  输出名字中包含该字符的用户信息,显示:
        用户姓名  用户年龄  夫人姓名 夫人年龄
  3.多对多
    1.什么是多对多
      A表中的一条数据可以与B表中的任意多条数据相关联
      B表中的一条数据可以与A表中的任意多条数据相关联
    2.在数据库中的体现
      在数据库中使用第三张表存储关联信息
    3.在Flask-SQLAlchemy中的实现
      1.创建关联表(实体类)
        class TeacherStudent(db.Model):
            __tablename__ = "teacher_student"
            id = db.Column(db.Integer, primary_key=True)
            tid = db.Column(db.Integer,db.ForeignKey('teacher.id'))
            sid = db.Column(db.Integer,db.ForeignKey('student.id'))
      2.增加 关联属性 和 反向引用关系属性(可以在Teacher中写,也可以在Student中写)
        class Teacher(db.Model):
            __tablename__ = 'teacher'
            ...
            students = db.relationship('Student',secondary='teacher_student',lazy='dynamic'
                       backref=db.backref("teachers",lazy='dynamic'))
            **第一个lazy控制的是teacher查询student时的加载方式,
              第二个lazy是反向student查找teacher时的加载方式
      [注]: 多对多的关联属性和反向引用属性 返回的都是Queru对象,可以使用.all(),.count()等取值
      3.在程序中插入关联信息到第三张信息表(append()方法)
        ex:
          
          tea = Teacher.query.filter_by(id=1).first()
          
          stu = Student.query.filter_by(id=1).first()

          # 用append()方法会把关联信息自动插入到关联信息表
          tea.students.append(stu)
    示例:day06/run01.py


        
**********************************************************************************************
---------------------------- 2018年1月3日 星期四 晴  ------cookies--------PythonWeb(day07)----- 
-cookies / cookie
  1.什么是cookies
    cookies是一种存储手段
    将一段文本保存在客户端(浏览器)的一种存储手段,并可以长时间保存
  2.cookies的使用场景
    1.记住密码
    2.记住搜索关键词,自动推送相关广告
  3.特点
    1.cookies是以浏览器为单位,不同的浏览器之间的cookies是不共享的
    2.各个网站之间的cookies也是相互独立的,不共享

    优点:
      1.可以解决服务器端的一些存储问题
        允许将非重要的数据保存在客户端浏览器中,从而节省服务端的空间
      2.可以长时间保存数据
    缺点:
      1.明文显示所有的数据
      2.cookie中的内容在客户端是允许被修改的

-Flask中使用cookies
  1.保存cookies
    要通过 响应对象 将cookies从服务器端带到浏览器上
    响应对象:
      1.resp = redirect("/重定向地址")  //from flask import redirect
        resp就是一个响应对象
      2.手动封装成 响应对象
        from flask import make_response
        resp = make_response("字符串"或render_template())
        return resp
    添加cookies的语法
      响应对象.set_cookie(key,value,max_age)
        key:      要保存的cookie的名称
        value:    要保存的cookie值
        max_age:  最大保存时间,取无单位的数值,代表s(常用60*60*24等方式存入/年/月/日)
      ex:
        @app.route("/01-addcookie")
        def addcookie_views():
            resp = make_response("添加cookie成功")
            resp.set_cookie('uname',"wangwc",60*60*24*365)
            return resp
  2.获取cookies
    每当浏览器向服务器发送请求时,都会把 当前站点 的cookies们都封装到request中,并带到
    服务器上
    语法:
      cook = request.cookies  //cook 为字典
    **一般取值时先判断是否有该值,因为cookies有可能被用户清除了,不加判断会使程序出错
    if 'uname' in request.cookies:
        uname = request.cookies['unmae']
  3.删除cookies
    响应对象.delete_cookie('key')
  
  练习: (day07/run01.py /03-register --> 03-register.html)
    get请求时:
      登录名称 [         ]
      登录密码 [         ]
      [√]记住密码
      [登录]
    POST请求时:
      1.接收提交过来的登录名称和登录密码
      2.登录名称 和 登录密码 的值都是admin的时候,认为登录成功
      3.如果勾住 记住密码 的话,将登录名和密码都存进 cookies, 存期为1年
      4.改进GET请求
        1.判断cookies中是否有登录名称和密码
        2.如果有的话,则获取出来该两个值进行登录验证,验证通过则提示"您已登录"
        3.如果验证失败,则直接显示登录界面
    结合session:
      1.登录成功后,将uname和upwd保存进session
      2.get请求时,先判断session中是否有登录信息,有则响应"您已成功登录"
      3.如果session中没有,则判断cookie中有没有相关信息
      4.如果session和cookie中都没有登录信息,则显示登录模板

-session - 会话
  1.什么是session
    session是保存在服务器上,为每个浏览器所开辟的一段空间
    sessionID保存在cookies,寿命为会话级,关闭浏览器则释放
  2.什么信息要存入session
    服务器端在会话过程中经常要用到的数据保存到session
  3.session在Flask中的实现手段
    1.配置 SECRET_KEY
      app.config['SECRET_KEY'] = '字符串'  //该字符串随便写,写得复杂生成的sessionID就复杂
    2.使用session
      from flask import session
      1.保存数据到session中
        session['key'] = value        
      2.从session中获取数据
        value = session['key']   //通常先判断'key' in session,避免报错
      3.从session中删除数据
        del session['key']
  示例: (day07/run02.py /01-addSession )
  
  练习:(day07/run03.py)
    完整的登录模块,含cookies/session/加密

-Flask 蓝图(Blueprint)    
  目的:将子应用关联到主应用上
  用法: 
    1.将子应用模块或者包(在子应用的__init__.py)加入到蓝图中
      from flask import Blueprint
      自定义蓝图实例名(如main_blue) = Blueprint('当前模块别名',__name__)
      [from . import 视图模块]
    2.在创建app的模块中将蓝图实例与app关联到一起
      from 子应用包 import main_blue
      app.register_blueprint(main_blue)
    3.在视图模块
      from . import main_blue
      @main_blue.route('/')
      def views():
        retrun

练习:
  -登录
    1.调整至登录页面后
      接收登录名 密码 并验证正确性
      登录成功后,将登录信息保存进session
      并跳转回源页面
    2.首页(源页面)登录的位置处需要显示 欢迎 用户名 退出
    3.完成退出功能
  2.发表博客
    路径: /release
    允许接收GET,POST
    1.GET请求
      如果没有登录,或者登录的用户is_auto不是True,则重定向回
      请求源地址
      否则: 允许显示release.html
  3.查看上一篇下一篇,(上一条数据,下一条数据)
    ** 不能采用当前id +1 / -1 的方式,因为id可能不连续
    查询上一条:
      查询比当前id小的最后一条数据
    查询下一条:
      查询比当前id大的第一条数据


