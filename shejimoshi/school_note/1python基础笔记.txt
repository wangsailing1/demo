2018.9.30  星期天  晴
--------------------------------------------------------------------------------------------------------
*************************** day1 回顾 *************************************************************************
-教学(开发、测试部署)环境的安装
  1.下载VMware workstation安装包并安装(该平台安装简单，下一步下一步即可)
  2.下载linux操作系统镜像文件.iso(纯净版): Ubuntu 16.04
  3.打开VMware Workstation,文件->新建虚拟机(相当组装电脑)
  4.CD/DVD-->插入光盘(.ISO文件)
  5.开启此虚拟机-->相当于通电开机
  6.操作系统安装完成后-->安装软件、模块等

-Linux的文件存储是不分区的，直接在根目录下创建不同文件夹
-Linux 一切皆文件
  目录也属于文件的一种,所以在同一个路径下不能有同名的文件和文件夹
   如已存在一个 day01的文件夹 再touch创建一个名为day01的文件,
   最终该文件没有成功创建
-用户主目录/家目录(/home/tarena)
  1.超级用户: root
    创建用户时root会自动在/home下创建一个和用户名相同的目录
    作为该用户的主目录

 -linux命令总结：
  -cp / cp - r 复制文件、文件夹
  -mv          移动文件/文件夹(重命名)
  -cat         显示文本文件的内容
  -tar         打包并压缩 $ tar - czvf 文件夹
               解包并压缩 $ tar - xzvf a.tar
  -mkdir       创建文件夹
  -rmdir       删除文件夹
  -touch       创建文件/更新文件的修改时间
  -chmod       修改文件权限（r:读/w:写/x:执行）
  -sudo        获取root用户权限，用权限执行命令
  -df          查看磁盘状态
  -top         任务管理器
  -ps          查看pid 进程
  -tree 目录名  查看目录的结构树 
  -tail         查看文件的尾部数据(通常用来查看日志文件) tail -10 文件名  查看最后10行       
  -more         

-文本编辑器 vi/vim(linux自带)
  格式：
    vi 文件名  #若文件不存在，保存时会自动创建
    -进入文本编辑器后(默认浏览模式)  按a进入插入模式
    -编辑完成后,ESC退出插入模式
    -shift + ":" 呼出命令行(命令行模式)   输入wq保存并退出 # wq --> write quit; w-->保存但不退出;q-->退出但不保存

-linux命令:
  cp(复制命令):
    1.复制文件 cp 源文件 路径/副本文件名
    2.复制目录 cp -r 源目录 路径      # -r指递归地复制，把子文件目录及其子文件等全部复制
    (可以采用*. 通配符批量复制)
  mv(移动(剪切)/重命名命令):
    1.移动文件 mv 源文件 路径/副本文件名
    2.移动目录 mv 源目录 路径     
    3.重命名  mv 源文件 新文件名  #事实上相当于将文件剪切走，再换一个名字放回来，造成了重命名的效果
    (可以采用*. 通配符批量复制)
  tar打包并压缩
    ------------压缩----------------------------
    1.格式
      tar -zcvf 压缩包名字.tar.gz 被压缩的文件/目录
    2. -zcvf释义
      -z: 用gzip进行压缩
      -c: 创建包(create)
      -v: 显示文件明细(verbose)
      -f: file
    -----------解压缩-------------------------
    1.格式
      tar -zxvf 压缩包名字.tar.gz [-C 路径]  #-C 需是大写,缺省则解压到当前
    2.释义：
      -zvf：与压缩语法相同
      -x:提取文件

-文件权限
  1.查看文件权限 ls -l
  文件类型+权限 文件数量 拥有者 所属组   大小     修改时间     文件名
   -rw-rw-r--     1    tarena tarena1  79   10月 16 20:12   1.txt
  2.最左侧一列代表文件类型   #当前看到的1.txt的最左侧是'-'
      - : 代表是普通文件
      d : 代表目录
      l : 链接
  3.权限说明
    r读 w写 x执行
    4   2   1     #最低权限是（4）只读  读写权限为6  读写加执行最高权限为7
  5.权限分组
    第一组: 文件的所有者(创建者)权限 rw-
    第二组: 同组的用户的权限,本例中则是tarena1组内所有用户 rw-
    第三组: 其他组用户的权限 r--

  4.更改文件权限
    chmod-更改文件的权限
    1.给三组权限都增加/减少权限
      chmod +x/-w/+rwx 1.txt
    2.给指定组修改权限
      chmod u+x 1.txt  #表示给user添加执行权限
      chmod o-r 1.txt
      chmod g+rw 1.txt
        注： 
        a : 即all,代表全部(缺省默认)
        u : 即user,代表用户(所有者)
        g : 即group,组
        o : 即other,其他
    3.通过数字更改权限
      4 : r
      2 : w
      1 : x
    例:chmod 666 1.txt  #表示 rw-rw-rw-
       chmod 644 1.txt  #表示 rw-r--r--
  5.可执行权限
    可以直接运行，但是要在文件内给它指定运行依赖的解析器
    如python文件，在首行写:
      #!/usr/bin/env python

-Linux实用高级命令
  1. sudo: 获取root用户的权限执行linux命令
 
-Python是解释型语言
  解释型语言和编译型语言??
    解释型: 在执行过程中,计算机一条一条第将代码解释成机器语言来运行
    编译型: 在执行前将源程序的每条语句都编译成机器语言，并保存成二进制文件
            再让机器直接执行，运行速度很快

 -python的执行：
  -$ python3 xxx.py
  -$ python3
   >>>  (python代码） #交互模式
   >>> exit or ctrl+d  #退出
-练习：
  1.用户主目录下创建tarena.txt
  2.在tarena.txt中写入"仰天大笑出门去，我辈岂是蓬蒿人"
  3.cat查看tarena.txt中的内容
 
 -python的数据类型
   字符串、数字、列表……
  -数字类型：
   -整型数 int
     -十进制：-100 0 99 99999999
     -十六进制：0x1234 0xABCD 0xabcd 0x11   # ? x代表什么(答: 0b1001 b代表2进制同理o代表8进制，x代表16进制)
     -八进制：0o12345670 0o11
     -二进制：0b11
   -浮点型数：float
     3.14  .14  3.  3.0
     314e-2  0.314e1 3.14e0
   -复数：complex
     (1+2j)
   -布尔型数：bool
     -ture  #计算机内部用1表示
     -false #计算机内部用0表示
  -字符串
   ''  ""
  -算数运算符
   +  -  * / //  %  **                    # %为求余数 **为幂运算
  - %字符串的格式化
 
--------------------------------------------------------------------------------------------------------
**************************** day02笔记 *****************************************************************
 
-vscode（Visual studio code） #出自Microsoft  
  -ctrl + +  / ctrl + -                   #缩放字体
  -注释 ctrl+/
  -保存 ctrl+s
  -启动vscode的命令：
   -$ code <回车>                         #打开一个新的编辑器
   -$ code 文件名<回车>
   -$ code 文件夹名<回车> 
 
-变量
  关联一个对象的标识符
  变量可以绑定一个对象，并可以通过变量名使用这个对象
 -标识符的命名方法                         #标识符区分大小写
  以字母或下划线开头，后跟字母、数字与下划线任意组合
  示例： a A a1 bbbb set_age _ _abcd 
  不合法的标识符： 1a 123 $ABC             #python关键字不能用作变量名

-表达式
  表达式是用来表达某种逻辑关系的，执行后会返回一个值
  -->语句通常由表达式来组成
-赋值语句 statement
 -符号 =
 -语法：
  变量名=表达式
  变量名1=变量名2=表达式
  变量名1,变量名2,...=序列
 -作用：
  创建一个变量并绑定数据对象
  改变一个变量的绑定数据对象
 -示例：
  a=10
  b=20
  c=a+b       #c绑定30
  a=b=c=10000 #同时改变三个变量的绑定关系
              #同时绑定在10000上
  x,y=100,200 #用x绑定100，用y绑定200

 -赋值语句说明
  1.当变量不存在时，赋值语句会创建该变量，同时将该变量绑定在赋值运算符右侧的对象上  
  2.当变量存在时，改变此变量的绑定关系
  3.一个变量只能绑定一个对象
  4.多个变量可以同时绑定一个对象上           

-del语句 
  用于删除变量，同时解除与对象的关联关系，如果可能则释放对象
 -语法
  del 变量名1,变量名2,...
 -在交互模式下查看当前作用域内的所有变量
  >>> help('__main__')
  示例：
   a = 100
   b = 200
   x,y=123,456
   del a
   del b,x,y #同时删除3个变量
 -del语句总结：
   1. 删除变量          del a,b,c
   2. 删除列表中的元素  del L[0],L[0:3]
   3. 删除字典中的键    del d['name']
   4. 删除实例属性      del dog1.fav

-自动化内存管理和引用计数
  每个对象都会记录有几个变量引用（绑定）自身，当引用的数量为0时，则
  这些对象被销毁，此种自动化内存管理的方式叫“引用计数”

-is 和 is not 运算符
 -作用：判断两个对象是否是同一个对象(判断的是id，不是值)，当是时返回true,否则返回false
 - is not 与 is 的返回值相反
 -语法：
   x is y
   x is not y
 -示例1：    
   a=b=1
   a is b            #返回true
   a is not b        #返回false
 -示例2：                  ??为什么 a=5+5 b=4+6  a is b 返回true，两者ID为什么是相同的（答：看小整数对象池概念）
   a=5000+5000
   b=4000+6000
   a is b            #返回false
   a is not b        #返回true

-id函数
 -作用：
    返回一个对象在内存中的地址
 -说明：is运算符是根据id来进行判断的
 -格式：
   id(对象)

-小整数对象池
 Cpython中，整数-5至256永远存在于小整数对象池中，不会释放，并可重复使用

-复合赋值算术运算符
 a=a+1
 a+=b   
 a-=b   
 a*=b   
 a/=b   
 a//=b   
 a%=b   
 a**=b   

-比较运算符
  <   小于
  <=  小于等于
  >   大于
  >=  大于等于
  ==  等于
  !=  不等于
 -语法：左表达式<右表达式
 -说明：比较运算符返回布尔型的值
 -示例1： 
   100<200   #返回true
   1+5==2+3  #返回false
 -示例2：
   x=60
   0<=x<=100  #返回true，从左至右运算，只要有一处出现false，则返回false

-数值对象的构造函数（创建函数）
  -float(obj)  用字符串或数字转换为浮点数，如果不给出参数，返回0.0
  -int(x,base=10)或int(x=0) 用数字或字符串转换为整数。如果不给出参数，返回0
    -int(3.14)  #返回3
    -int(3.99)  #返回3，该函数均向下取整
    -int('111',10)  #返回111
      -int('111',2) #返回7，第二个参数为换算进制底数，最多到36进制
  -complex(r=0.0,i=0.0) 用数字创建一个复数（实部为r，虚部为i）
    -complex(1,2) #返回1+2j
  -bool(x)  用x创建一个布尔值(true/false)   
    -bool(100)  #返回true
    -bool(0)    #返回false
    -只有以下情况会返回false
      none  空值
      false 布尔假值
      0  0.0  0j  数字0
      ---以下后面学---
      ''  空字符串
      []  空列表
      ()  空元祖
      {}  空字典
      ...
 -函数调用的语法：
   函数名（传参列表）
   说明：
     函数调用是一个表达式，一定会返回一个对象的引用关系（或者返回none）
     
-预置（內建）的数值型函数
  -abs(x)  取x的绝对值
  -round(number[,ndigit])  对数值进行"四舍五入",ndigit是小数向右取整的位数，负数表示向左取整
  -pow(x,y,z=none)  相当于x**y或x**y%z

  -示例
    abs(-100)            #100
    round(1234.5678)     #1235
    round(1234.5678,2)   #1234.57
    round(1234.5678,-2)  #1200.0
    pow(5,2)             #25
    pow(5,2,10)          #5

-help()函数  #查看函数的帮助
  >>>help(函数名) #查看相应函数的帮助

-语句 statement
    -语句由一些表达式组成，通常一条语句可以独立地执行来完成
     一部分事情
    -多条语句写在一行内要用分号(;)分开
  -示例：
    code/statement.py

-显式折行：
  -当语句太长时，一行无法摆放，用\（反斜杠）进行显式折行
  -示例：
    a=1+2+3+5+8\
    +7+9+5+20+30    #等同于a=1+2+3+5+8+7+9+5+20+30

-隐式折行
  -所有的括号的内容换行，称为隐式折行 
  -示例：
    a=(1+2+3+5+8
    +7+9+5+20+30)    #等同于a=1+2+3+5+8+7+9+5+20+30,用括号把语句括起来
  -能用于隐式折行的括号有：
    ()  []  {}

-基本输入输出函数
  -基本输入函数 input
    -作用：
      从一个标准输入设备上读取一个字符串(不包含换行符)
    -格式：
      input('提示字符串')
    -说明：
      返回用户输入的字符串
      '提示字符串'可以为空
    -示例：
      s = input("请输入您要去的地方：")
      print("您要去:",s)

-基本输出函数 print
  -格式：
    print(value,...,sep='',end='\n',
    file=sys.stdout,flush=false)
    将一系列的值以字符串形式输出到标准输出设备上（默认为终端）
  -参数选项：
    sep: 两个值之间的分隔符(默认为一个空格' ')
      -示例：
   　　　print(1,2,3,4)          #输出1 2 3 4
  　　　 print(1,2,3,4,sep=' ')  #默认状态
  　　　 print(1,2,3,4,sep='#')  #输出1#2#3#4
  　　　 print(1,2,3,4,sep='')   #输出1234
    end: 输出完毕后在末尾自动追加一个字符串（默认为换行符'\n'）
　　　-示例1：
        print(1,2,3,4)         #默认为print(1,2,3,4,end='\n')
        print(1,2,3,4)

        ---以上语句输出---
        1 2 3 4
        1 2 3 4
     -示例2
        print(1,2,3,4,end='')  #常用于不换行
        print(1,2,3,4)

        ---以上语句输出---
        1 2 3 41 2 3 4 
    
        
-练习
  1.输入两个整数，分别用变量x,y绑定
   1)计算这两个数的和，并打印结果
   2)计算这两个数的积，并打印结果
   3)计算x的次方，并打印结果
  2.分三次输入当前时间的小时，分钟，秒数
    在终端计算距离凌晨0:0:0过了多少秒
  3.计算三险一金：
    已知社保的缴费比率是：
     项目      个人缴费比例      单位缴费比例
     养老保险      8%                19%
     工伤保险      0%                0.5%
     医疗保险      2%+3元            10%   　　
     住房公积金    12%               12%
    输入您在北京的社保基数(如:5000)
      打印您的公司的各项缴费明细、个人总缴费金额、
      单位缴费金额及国家拿到的钱是多少？
      
--------------------------------------------------------------------------------------------------------
**************************** 2018年10月6日  星期六 晴  (自习) ********************************************
                        #如何知道二进制数中的第一个是不是符号？按位取反的再加一的原理是什么？
《Linux基础教程》
-目录树
 根 / 代表文件系统的起始位置
 路径：
  表达一个文件或文件夹位置的字符串
  例：/home/tarena/aid1711/day01.txt

-终端工具
  打开方法：
    1.点击图标
    2.点击"搜索计算机"输入"gnome 或 terminal"

-linux命令：
  格式：
  命令名 [选项] [参数]
  命令库：
    pwd：用于显示当前操作的路径位置
    ls:显示指定目录的文件或文件夹信息
      格式：ls [选项] [文件夹名/文件名]
        常用选项：
          -l 列表显示文件的详细信息
          -a 显示全部文件/文件夹
        例：ls -l /home/tarena
            ls -l -a /home/tarena
          列表显示中在权限栏以d开头的是目录：
           d  目录
           -  文件
           l  链接
    mkdir:创建一个或多个文件夹
      格式: mkdir [选项] 文件夹1 文件夹2 文件夹3
      例如: mkdir a b c   #分别创建3个命名为a、b、c的文件夹
      常用选项：
        -p 逐级创建文件夹
          例：mkdir -p a/b/c
    rmdir:删除一个或多个文件夹(文件夹内必须为空)
      格式:rmdir [选项] 文件夹名
        例:rmdir a b c
    rm命令:删除文件或文件夹
      格式:rm [选项] 文件或文件夹
      常用选项：
       -r 删除全部文件或文件夹(包含文件夹内的全部内容)
       -i 删除前提示(y代表yes,n代表no)
       -f 强制删除,不给任何提示
    touch命令:
      作用:
        1.如果文件不存在，则创建文件
        2.如果文件存在,则用系统时间更新其修改时间
      格式:
        touch 文件或文件夹  
      例: touch 1.txt 2.txt
    cd命令: 改变当前工作目录(进入某个目录)
      格式: cd 路径   (cd <回车> 可以直接回到用户主目录)
            cd -     # 跳回上一次所在的工作目录
    ctrl + c 终止命令执行
    ctrl + shift + '='  终端字体放大
    ctrl + '-'  终端字体减小

-linux下的路径
  路径分两种：
    绝对路径：以/字符开头的为绝对路径，一个文件的绝对路径通常是唯一的
    相对路径：不以/开头的路径
      相对路径的开始符号：
        .  当前文件夹
        .. 上一级文件夹
        ~  用户主目录

-操作带有特殊字符的路径的方法
  用两个半角的英文双引号(")把路径括起来
   例:mkdir "a b c"
      rmdir "~/tarena/a b c"

-tab键命令补全
  作用:
    命令补全
    路径补全
    提示

-history命令:查看以前输入过的历史命令
  所有的操作记录会记录在名为".bash_history"的文件里面

-命令的帮助
  三种方法：
    1.命令名 --help
    2.help 命令名
    3.man 命令名

-通配符
  *代表0个、1个或多个任意字符
  ?代表1个任意字符
  示例:
    touch a ab abc bc bcd cd aabb   #创建一个或多个文件
    rm a*                           #a*代表以a开头的文件，该命令删除了这些文件
      注:a*代表以a开头的文件
         a*b代表以a开头，以b结尾的文件
         *b代表以b结尾的文件
         a*d*b 代表以a开头，中间有d，且以b结尾的文件
    "?"的道理跟"*"一样，只是"?"代表的是一个字符

--------------------------------------------------------------------------------------------------------
**************************** 2018年10月7日  星期日 晴  (自习) ********************************************
-cp命令:复制文件或文件夹
  格式:cp [选项] 原文件夹/文件名 目的文件夹/文件名
    例: cp day02.txt day02_backup.txt   #在当前文件夹备份文件
        cp day02.txt ~                  #将文件备份到其他目录下，采用与源相同的文件名
  常用选项:
    -a 复制文件夹内的内容
      例:cp -a day02 ~     #复制文件夹day02到用户主目录下
     
-clear命令
  作用:清屏
  快捷键: ctrl+l

-find命令
  作用:通过文件名查找文件         #类似于windows的"在路径下搜索"的功能
  格式:find 路径 -name"文件名" [-type d/f]
      * -type f 表示查找文件(缺省值)  -type d 表示查找目录
  示例:在用户主目录下查找名为"2.py"的文件
    find ~ -name "2.py"
    #返回文件的具体路径
  例：
   find /home/tarena -name hello.py
   find / -name hello.py                    #在整个计算机文件系统中查找

-文本文件编辑器
  常见编辑器:
    ecllipse(java写的)
    vim(c语言写的)
    sublime text 3(c/c++/python写的)
    visual studio code(出自Microsoft)

-VScode
  ctrl + d 可以选择多个相同的字符  
  ctrl + c 复制光标所在的行  
  ctrl + + 字体放大
  ctrl + - 字体缩小

--------------------------------------------------------------------------------------------------------
**************************** 2018年10月8日  星期一 晴   day03********************************************
- if 语句
  作用：
    让程序根据条件选择性地执行某条语句或某些语句
  语法：
    if 真值表达式1:
        语句块1...           #所有的语句块要缩进，这类语句叫(复合语句)
    elif 真值表达式2:
        语句块2...           #官方统一用4个空格来缩进(不要用tab)
    elif 真值表达式3:
        语句块3...
    else:
        语句块4...
  说明:
    elif 子语句可以有0个，1个或多个
    else 子语句可以有0个或1个，且只能放在if语句的句末

  练习1:
    任意输入一个整数
      1)判断这个数是否大于100
      2)判断这个数是否小于0
      3)判断这个数是否在50~100之间
      (建议每一步用一个if语句来实现)

  练习2:
    1.输入一个季度1~4,输出这个季度有哪几个月份，
      如果输入的不是1~4的整数，提示用户您输错了

    2.输入一年中的月份(1~12)，输出这几个月在哪个季度。
      如果输入的是其他数，则提示您输错了

-if语句的嵌套
  if语句可以作为语句嵌套到另一个复合语句的内部
  
-条件表达式
  语法：
    表达式1 if 真值表达式 else 表达式2
  作用：
    根据真值表达式的取值(true/false)来决定执行表达式1或者表达式2并返回结果
  示例：
        #此示例示意条件表达式的语法和用法
        #商场促销，满100减20
        money = int(input("请输入商品总额："))
        pay = money - 20 if money > 100 else money   #先执行中间真值表达式，如果true则执行前表达式
        print('您需要支付',pay,'元')
  练习：
    1.输入一个数，用if语句计算出这个数的绝对值并打印
    2.输入一个数，用条件表达式计算出这个数的绝对值并打印
    
-pass语句
  作用：
    通常用来填充语法空白
    pass又名空语句
  语法：
    pass
  
-布尔运算
  and or not
  与  或  非
  -布尔非操作(not)
    语法：
      not x
    作用：
      对x进行布尔取非，如bool(x)为true,则返回false，否则返回true
    例：
      not 1
      #返回false
      not 0
      #返回true
  -布尔与操作(and)
    语法：
      x and y
      注：x,y代表表达式
    作用：
      优先返回假值对象，当x的布尔值为false时，返回x,否则返回y
    示例：
      true and true  #返回true
      true and false #返回false
      0 and 1        #返回0
      100 and 0      #返回0
  -布尔或操作(or)
    语法：
      x or y
    作用：
      优先返回真值对象，当x为true时返回x，否则返回y
    
-正负号运算符
  +(正号) -(负号)
  注：一元运算符(一个元素参加运算)

  语法：
    + 表达式
    - 表达式
  示例：
    a = 5
    b = -a
    c = +a
    print(a,b,c)  #输出5 -5 5

字符串 str
  作用：
    用来记录文字(文本)信息
  表示方法：
    在非注释中凡是引用括号括起来的部分都是字符串
    '    #单引号
    "    #双引号
    '''  #三单引号
    """  #三双引号
  单引号和双引号的区别
    单引号内的双引号不算结束符
    双引号内的单引号不算结束符
    示例：
      print("I'm a teacher")    #语句合法
      print('I'm a teacher')    #语法错误
  三引号字符串的作用
    三引号字符串可以包含单引号和双引号
    三引号字符串中的换行会自动转换为换行符'\n'
    示例：
      见test.py中 test6
  隐式字符串字面值拼接
    示例：
      s = "I'm a teacher"  'my name is "tarena"'
      print(s)
      #输出I'm a teachermy name is "tarena"
  空字符串的布尔值为false
    bool("")
    >>>false
  
-用转义序列代表特殊字符
  字符串字面值中用字符反斜杠\后跟一些字符代表特殊的一个字符
  转字格式：
    \'  代表一个单引号
    \"  代表一个双引号
    \\  代表一个反斜杠
    \n  代表换行
    \r  返回光标至行首  #例：print("ABCD\rab")  输出abCD
    \f  换页
    \t  水平制表符
    \v  垂直制表符
    \b  倒退           #例：print("ABCD\ba")  输出ABCa
    \0  空字符
    \0oo   oo为两位八进制表示的字符
    \xXX   XX为两位十六进制表示的字符
    \uXXXX   四位十六进制表示的Unicode 16字符
    \UXXXXXXXX  八位十六进制表示的Unicode 32字符  

-ASCII编码表
  $man ascii

  常用的ASCII 编码
    字符    十进制    十六进制
    '0'      48        0x30
    'A'      65        0X41
    'a'      97        0x61

-序列的概念
  字符串是序列(有序排列)
  所有的序列都能用len(x)函数求其长度

-len(x)函数
  返回字符串中字符的个数(求的是字符的个数，而不是字符的内存空间(一个中文占2字节)
   如：一个中文在字符串中是一个字符)
  
-raw字符串(原始字符串)
  格式:
    r'字符串内容'
    r"字符串内容"
    r'''字符串内容'''
    r"""字符串内容"""
  作用:
    让转义符号反斜杠\无效
  示例： 
    a = 'C:\newfile\test.py'
    print(a)
    print(len(a))         
    a = r'C:\newfile\test.py'
    print(a)
    print(len(a))

-字符串的运算
  运算符
    +   +=   *   *=

  +号运算符用于拼接字符串
    x = "ABCD"
    y = "123"
    z = x + y
    print(z)      #ABCD123

  +=用于原字符串与右侧字符串拼接，再用变量绑定新的字符串
    x = "ABC"
    y = "123"
    x += y
    print(x)  #ABC123,等同于x = x + y

  *运算符用于生成重复的字符串
    x = "ABC" * 3        #字符串只能与整数相乘
    print(x)             #ABCABCABC

  *=运算符用于生成重复的字符串，再用原变量绑定
    x = "123"
    x *= 2
    print(x)     #123123

-字符串的比较运算
  运算符：
    <  <=   >   >=   ==   !=
  比较规则：
    依次按编码值进行两两字符比较，一旦不同，则比较结束并返回结果
    当编码值和长度完全相同时，两字符串相同
  示例：
    "A" < 'B'       #true
    'ABC' < 'ABB'   #true
    'ADC' < 'ABC'   #false
    'ABC' >= '123'  #true
    'AB' < "ABC"    #ture
    'abc' == 'ABC'  #false

-in , not in运算符
  作用：
    in用于序列，字典，集合中，用于判断某个值是否存于
    容器中，如果存在则返回true,否则返回false
    not in 与 in 运算符的返回结果相反
  格式：
    对象in序列
  示例：
    x = 'welcome to tarena'
    'to' in x       #true
    'hello' in x    #false
    'e t' in x      #true
    'abc' not in x  #true

练习：
  1.北京出租车计价器：
    收费标准：
      3公里以内收费 13元
      基本单价 2.3元/公里(超出3公里以外)
      空驶费:超过15公里后,每公里加收单价50%的空驶费(3.45元/公里)
    要求:输入公里数，打印出费用金额
  2.输入一个学生的三科成绩:
    1)打印出最高分是多少分
    2)打印出最低分是多少分
    3)打印出平均分是多少分
  3.计算BMI指数(body mass index)又称身体质量指数
    计算公式:
      BMI = 体重(kg)/身高的平方(m)
    标准表:
      BMI < 18.5         体重过轻
      18.5 <= BMI <= 24  体重正常
      BMI >= 24          体重过重
    要求：输入身高和体重，打印BMI的值，并打印体重情况

  4.打印一个高度为4行的矩形方框
    要求输入一个整数，次整数代表矩形的宽度
    如：
      请输入矩形宽度:10
    打印如下:
      ##########
      #        #
      #        #
      ##########
    如果输入的数字越大，矩形会越宽

-grep命令
  作用:
    根据文件内容查找相应的文件
  格式：
    grep "内容" [选项]  文件名或路径
  常用选项：
    -n    显示行号
    -R/-r 递归搜索文件夹内的文件或文件夹
  例：
    grep "100元" *.txt
    grep "tedu" -R

--------------------------------------------------------------------------------------------------------
**************************** 2018年10月9日  星期二 晴   day04********************************************
-字符串的基本操作：
  索引：index
    python字符串是不可以改变的字符序列
    索引取值语法：
      字符串[整数表达式]
  说明：
    python的序列都可以用索引(index)来访问序列中的对象
    python序列的正向索引是从0开始，最后一个索引为len(s)-1
    python序列的反向索引是从-1开始时的，-1代表最后一个,
      -2代表倒数第二个，以此类推。第一个是-len(s)
  示例：
    s = "ABCDE"
    print(s[1])  #B
    print(s[4])  #E
    print(s[-1]) #E
    print(s[-5]) #A
    print(s[100]) #index error 越界

-字符串的切片 slice
  作用：
    从字符串序列中取出相应的元素重新组成一个新的字符串
  语法：
    字符串[(开始索引b):(结束索引e)(:(步长s))]
    注：小括号()括起来的部分代表可以省略,包括开始索引、结束索引都可以省略
  说明:
    开始索引是切片开始切下的位置，0代表第一个元素,1代表第二个元素
    -1代表最后一个
    结束索引是切片的终止索引(但不包含终止点)
    步长是切片每次获取完当前元素后移动的方向和偏移量
      1.没有步长，相当于步长为1(默认值为1)  
      2.当步长为正整数时，取正向切片
      3.当步长为负整数时，取反向切片
        当反向切片时，默认的起始位置为最后一个元素，
        终止位置的第一个元素的位置
  示例:
    s = "ABCDE"
    a = s[1:4]   #a-->"BCD"
    a = s[:4]    #a-->"ABCD"不给起始值默认从0开始
    a = s[1:]    #a-->"BCDE"不给结束值默认切至末尾，同s[1:5]
    a = s[:]     #a-->"ABCDE"
    a = s[1:1]   #a-->""空字符串
    a = s[4:2]   #a-->""空字符串
    a = s[0:5:2]  #a-->"ACE"步长为2
    a = s[4:0:-2] #a-->"EC"
    a = s[4::-2]  #a-->"ECA"

  练习：
    1.输入一个字符串，把字符串的第一个字符和最后一个字符去掉后，
      打印出处理后的字符   答：见test 2
    2.写程序，输入任意字符串，判断这个字符串是否是回文
      回文指中心对称的文字

-python3中能用于字符串的函数
  len(x)  返回字符串长度
  max(x)  返回字符串编码值最大的字符
  min(x)  返回字符串中编码值最小的字符

-字符串的编码转换函数:
  ord(c)  返回一个字符c的unicode编码值
  chr(i)  返回i这个值所对应的字符
  示例：
    x = ord('A')  # x = 65
    c = chr(66)   # c = 'B'
  练习：
    1.写一个程序，输入一段字符串，如果字符串不为空，
      则把第一个字符的编码值打印出来
    2.写一个程序，输入一个整数(0~65535)，打印这个数值
      所对应的字符

-整数转换为字符串的函数：
  bin(i)  将整数转换为二进制字符串
  oct(i)  将整数转换为八进制字符串
  hex(i)  将整数转换为十六进制字符串
  例： 
    bin(9)  #返回0b1001
    oct(9)  #返回0o11
    hex(9)  #返回0x9

-字符串构造(创建)函数
  str(obj) 将对象转换为字符串
  示例：
    "123" + 456       #出错
    "123" + str(456)  #结果 "123456"

-python3中常用的字符串方法(method)
  方法的调用语法:
    对象.方法名(方法传参)
  示例：
    "abc".isalpha()  #返回true,"isalpha"用于判断是否全为字母
    "123".isalpha()  #返回false
     123.isalpha()   #出错
  常用方法见文档:
    python_base_docs_html str.html
    可以在交互模式下>>>help(str)
    -s.center(width,character)例：
      s = "123"
      s.center(20)     #-->"     123     "
      s.center(20,#)   #-->"######123######"
    -s.count(obj,star,stop)示例：
      s = "abcdeab"
      s.count("a")      #-->2
      s.count("bc")     #-->1
      s.count("ab",2)   #-->1
      s.count("ab",2,6) #-->0 
      s.count("ab",2,7) #-->1
    -s.strip()示例：
      s = "  ABC  "
      s.strip()       #-->"ABC"
      s = "  AB C  "
      s.strip()       #-->"AB C"
      s = "###ABC###"
      s.strip(#)      #-->"ABC"
    -s.replace()示例：
      s = "abcdeabab"
      s.replace("a","#")  #-->'#bcde#b#b'
      s = "abcdeabab"
      s.replace("a","#",2)  #-->'#bcde#bab'替换前两个

    S.isdigit() 	                        判断字符串中的字符是否全为数字
    S.isalpha() 	                        判断字符串是否全为英文字母
    S.islower() 	                        判断字符串所有字符是否全为小写英文字母
    S.isupper() 	                        判断字符串所有字符是否全为大写英文字母
    S.isspace() 	                        判断字符串是否全为空白字符
    S.center(width[,fill]) 	              将原字符串居中，左右默认填充空格
    S.count(sub[, start[,end]]) 	        获取一个字符串中子串的个数
    S.find(sub[, start[,end]]) 	          获取字符串中子串sub的索引,失败返回-1
    S.strip([chars]) 	                    返回去掉左右char字符的字符串(默认char为空白字符)
    S.lstrip([chars]) 	                  返回去掉左侧char字符的字符串(默认char为空白字符)
    S.rstrip([chars]) 	                  返回去掉右侧char字符的字符串(默认char为空白字符)
    S.upper() 	                          生成将英文转换为大写的字符串
    S.lower() 	                          生成将英文转换为小写的字符串
    S.replace(old, new[, count]) 	        将原字符串的old用new代替，生成一个新的字符串(原字符串不变)
    S.startswith(prefix[, start[, end]]) 	返回S是否是以prefix开头，如果以prefix开头返回True,否则返回False,
    S.endswith(suffix[, start[, end]]) 	  返回S是否是以suffix结尾，如果以suffix结尾返回True,否则返回False
	
    S.title() 	                          生成每个英文单词的首字母大写字符串
    S.isnumeric() 	                      判断字符串是否全为数字字符

    练习：
      输入一个字符串：  (答：见test 6)
        1.判断输入的字符串有几个空格
        2.将原字符串的左右空白字符去掉，打印出有效字符个数
        3.判断您输入的是否是数字，如果是数字，判断输入的数字是否大于100

-字符串格式化表达式：
  作用:
    生成一定格式的字符串
  运算符:
    %
  语法格式：
    格式化字符串 % 参数值
    格式化字符串 % (参数值1,参数值2,参数值3,...)
  说明:
    格式化字符串中以%开头的字符为占位符,占位符的位置将用参数值替换
  示例：
    fmt = "name: %s, age: %d"
    s2 = fmt % ("tarena",15)
  格式化字符串中的占位符类型码:
    占位符类型码    含义
      %s           字符串，使用str(x)函数转换
      %r           字符串，使用repr(x)函数转换        #?? %s和%r的区别
      %c           整数转换为单个字符
      %d           十进制整数
      %o           八进制整数
      %x           十六进制整数（字符a-f小写）
      %X           十六进制整数（字符A-F大写）
      %e           指数型浮点数(e小写)如：2.0e8
      %E           指数型浮点数(E大写)如：1.0E8
      %f,%F        十进制浮点数
      %g,%G        十进制形式浮点或指数浮点自动转换
      %%           等同于一个%字符

-占位符和类型码之间的格式语法
  % [- + 0 宽度.精度] 类型码
    -    左对齐(默认是右对齐)
    +    显示正号
    0    左侧空白位置补零
    宽度  整个数据显示的宽度
    精度  保留小数点后多少位
  示例：
   "%10d" % 123           # "      123"
   "%-10d" % 123          # "123      "
   "%05d" % 123           # "00123"
   "%+05d" % 123          # "+0123"
   "%7.3f" % 3.1415926    # "  3.142"
   "%4.2e" % 29000000     # '2.90e+07'

  练习：(见test 7)
    输入三行文字，让这三行文字依次以20个字符的宽度右对齐显示
      如:
        请输入第一行: hello world
        请输入第二行: abcd
        请输入第三行: aaaaaa
      打印如下：
                 hello world
                        abcd
                      aaaaaa
      做完后思考：
        能否以最长的字符串的长度进行右对齐显示(左侧填充
        空格)

-循环语句
  -while语句
    作用：
      根据一定条件，重复执行一条语句或多条语句
    语法：
      while 真值表达式：
          语句块1(此部分语句可能会重复执行多次)
      else:
          语句块2
    说明： 
      1.先执行真值表达式，得到布尔值为true或false
      2.如果真值表达式的值为true，则执行语句块1，然后再
        次返回到第一步，重复执行直至真值表达式为false
      3.如果真值表达式值为false,则执行else子句部分，然后
        结束次while循环
        注：else子句部分可以省略(类似if)
    示例：
      输入一个n用while语句打印n行，见test 8
  -while语句的嵌套
    while 真值表达式:
        ...
        while 真值表达式2：
            ...
        else:
            ...
        ...
    else:
        ...
  示例见test9
  练习：
    输入一个整数n，打印指定宽度的正方形(见test 10)
    如：
      输入5
      打印：
      1 2 3 4 5
      1 2 3 4 5
      1 2 3 4 5
      1 2 3 4 5
      1 2 3 4 5

  练习：
    1.输入三行文字，让这三行文字在一个方框内居中显示
    如输入：
      hello!
      I'm studing python!
      I like python!
    显示如下：
      +-------------------+
      |      hello!       |
      |I'm studing python!|
      |   I like python!  |
      +-------------------+
    2.用while循环打印1~20的整数(可以打印多行)
    3.用while循环打印1~20的整数,打印在一行显示
      每个数字之间用一个空格分隔
       1 2 3 4 5 6 ... 18 19 20
    4.用while循环打印1~20的整数，每行打印5个，
      打印4行，如：
       1 2 3 4 5
       6 7 8 9 10
       ...
    5.输入一个整数n，打印一个宽度和高度都为n个字符的长方形
      如：
        请输入:4
      打印：
        ####
        #  #
        #  #
        ####
      如：
        请输入:6
      打印：
        ######
        #    #
        #    #
        #    #
        #    #
        ######
    6.#输入一个整数
      #输出如下：
      # 1
      # 12
      # 123
      # ...
      # 123..n
    7.输入一个整数n代表结束的数值.求下列表达式的和：
      1 + 2 + 3 + 4 + ... (n-1) + n
      如：
        输入100,打印5050

  -for语句
    作用：
      用于遍历可迭代对象的数据元素
        可迭代对象是指能依次获取数据元素的对象
        如：
          str字符串，list[]列表，元祖，range()函数返回的对象等
    语法：
      for 变量列表 in 可迭代对象：
          语句块1(此处是可能重复执行的语句块)
      else:
          语句块2
    说明：
      1.当循环体内部用break终止循环时，else子句部分的语句
        不会被执行
      2.else子句部分可以省略
    示例：
      s = "ABCDE"
      for ch in s:            #每次向可迭代对象索取数据，当对象无法提供数据时，结束循环，执行else
          print("ch-->",ch)
      else:
          print("for语句的else子句被执行")
      print("程式结束")
      输出：
        ch--> A
        ch--> B
        ch--> C
        ch--> D
        ch--> E
        for语句的else字句被执行
        程式结束
    练习：(见test11)
      任意输入一段字符串
        1)计算出字符串中空格的个数
        2)计算出字符串中中文字符的个数
          (注：中文字符的编码值大于128)


-break语句
  作用:
    用于循环语句(while,for语句)中，用来终止当前循环
    语句的执行.
  说明：
    1.当break语句执行后,此循环语句break之后的语句不再执行
      break语句通常和if语句组合使用
    2.break语句终止循环时，循环语句的else子句的语句不会执行
    3.break语句只能终止当前循环语句的执行，如果有循环嵌套时，
      只会跳出当层循环，不会终止外层循环
    4.break语句只能在循环语句(while,for语句)的内部使用

-死循环
  死循环是指循环条件一直成立的循环
  死循环能通常用break语句来终止循环
  死循环的else子句永远不会被执行
  
  示例：(见test 10)
    让用户输入一些整数，当输入复数时结束输入，并打印这些数
    的和
    如：
    输入：1
    输入：2
    输入：3
    输入：4
    输入：-1
    打印：10



*****晚自习（补缺课内容）*******
-gzip命令
  作用：
    将文件以zip压缩算法进行压缩，生成压缩后的文件(不保留原文件)
  语法：
    gzip 文件名
  
-gunzip命令
  作用：
    将以zip算法的.gz压缩文件进行解压缩
  格式：
    gunzip 文件名

--------------------------------------------------------------------------------------------------------
**************************** 2018年10月10日  星期三 阴转阵雨   day05********************************************
-range()函数：
  range(stop)               用来生成0~stop区间内的整数，不包含stop
  range(star,stop[,step])   用来生成star~stop区间内的整数，包含star
                            不包含stop,step控制步长
  格式详见：
    >>> help(range)
  作用：
    用来创建一个生成一系列整数的可迭代对象(也叫整数序列生成器)
  示意：
    range(4)        生成 0,1,2,3
    range(3,6)      生成 3,4,5
    range(1,10,2)   生成 1,3,5,7,9
    range(5,0,-1)   生成 5,4,3,2,1
  练习：(见test 1)
    1.打印1~20的整数，打印在一行(用for语句实现)
    2.计算1 + 2 + 3 + 4 + ... + 99 + 100的和(用for实现)
    3.计算1 + 3 + 5 + 7 + ... + 97 + 99的和

-for语句的嵌套
  示例：
    for x in "ABC":
        for y in "123":
            print(x+y)
    输出：A1 A2 A3 ... C3

-continue语句
  作用:
    用于循环语句(while,for)中，不再执行本次循环内continue之后
    的语句，重新开始一次新的循环
  说明：
    1.在while语句中执行continue语句，将会直接跳转到while语句的真值
      表达式处，重新判断循环条件
    2.在for语句中执行continue语句，将会从可迭代对象中取下一个数据
      绑定变量后再次进行循环
  示例：
    打印10以内的偶数
      for n in range(10):
        if n % 2 == 1:
            continue
        print(n)
  练习：(见test 2)
    求1~100之间所有不能被2,3,5,7整除的数的和并打印

-列表 list
    列表属于容器的一种
    列表是可以被改变的序列容器
  创建空列表：
    L = []        #L绑定一个新创建的空列表
  创建非空列表：   #len()函数可以求列表内元素的个数
    L = [1,2,3,4]
    L = ["北京","上海","深圳"]
    L = [1,"二",3.14,"four"]           #该列表有4个元素
    L = [1,2,[1.1,2.1,3.1],4]          #该列表有4个元素，其中有一个元素是列表，该元素内又包含3个元素
  
-列表的构造(创建)函数 list()
  list()         创建一个空列表，等同[]
  list(iterable) 用可迭代对象创建一个列表
    示例：
      L = list("hello")    #L绑定['h','e','l','l','o']
      L = list(range(10))  #L绑定[0,1,2,3...,9]
    
-列表的运算：
  算数运算符
    +  +=  *  *=
  示例：
    + 号用于拼接列表(必须都是列表才可+)
      x = [1,2,3]
      y = [4,5,6]
      z = x + y     #z = [1,2,3,4,5,6]
    += 用于原列表与右侧可迭代对象(不一定要是列表)拼接，在原列表末尾追加数据
      语法：
        x += 可迭代对象
        如：
          x = [1,2,3]
          y = [4,5,6]
          x += y      #x绑定[1,2,3,4,5,6]
                      #不等同于L = L + [3],用+=运算时L的id不会变,
                       若用L = L + [3]时L的ID会变化，相当于创建了一个新的列表
          x += "abc"  #x绑定[1,2,3,'a','b','c']
    * 用于生成重复的列表
    *= 让原列表重复n次
      如：
        x = [1,2] * 3   #x = [1,2,1,2,1,2]
        x = [1,2]
        x *= 2          #x = [1,2,1,2]

练习：
  1.输入一个整数，此整数代表三角形的直角边长，
    根据整数n打印如下四种三角形(for和while都尝试)
      如输入:3
      打印：
        1)
          *
          **
          ***
        2)
            *
           **
          ***
        3)
          ***
          **
          *
        4)
          ***
           **
            *
  2.任意输入一个整数，判断这个整数是否是素数(prime)
    素数(也叫质数)，只能被1和自身整除的正整数
      提示：
        判断x是否为素数时，只要让x分别除以
        2,3,4,...,x-1,只要有一个能整除，则
        x不是素数，否则是素数
  3.输入一个正整数代表正方形的宽和高，打印如下正方形
    如：
      输入：5
    打印：
      1 2 3 4 5
      2 3 4 5 6
      3 4 5 6 7
      4 5 6 7 8
      5 6 7 8 9

--------------------------------------------------------------------------------------------------------
**************************** 2018年10月11日  星期四 阴   day06********************************************
python.org  #pyhton官网，Documentation->docs可以查看相关文档

-列表的比较运算
  运算符：
    <  <=  >  >=  ==  !=
  说明：
    列表的比较规则与字符串的比较规则相同
    列表要求每两个元素能依次进行比较，否则会出现类型错误
  示例：
    [1,2,3] < [1,2,4]             # true
    [1,2,3] != [1,2,4]            # true
    [1,2,3] < [1,3]               # true,两两比较,分出大小就直接返回结果,与长度无关
    ["one","two"] < ["1","2"]     # false
    [1,"two"] > ["two",1]         # type error

-列表的in / not in 运算符
  判断一个值是否存在于列表中，如果存在则返回true,
  否则返回false
  同字符串的in运算符类似

  示例：
    x = [1, "Two", 3, "四"]
    3 in x       # ture
    "3" in x     #false
    10 not in x  #ture

-列表的索引和切片
  索引取值语法：
    x = 列表[整数表达式]
    用法：
      等同于字符串的索引(同样分正向索引(0)和反向索引(-1))
  索引赋值：
    列表是可变的序列，可以通过索引赋值改变列表中的元素
    语法：
      列表[整数表达式] = 表达式
    示例：
      x = [1, 2, 3, 4]
      x[2] = 1 + 2.14   # 改变了第三个元素的值
      print(x)          # [1, 2, 3.14, 4]
  切片取值：
    列表[起始索引:终止索引:步长]
    列表的切片取值是从原列表中取出想要的元素再次组成一个新
    的列表
    示例：
      L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
      y = L[1:9:2]    # [1, 3, 5, 7] 返回的类型是列表，不是列表内的元素
  切片的赋值操作：
    作用:
      可以改变原列表的排列，可以插入和修改数据
    语法：
      列表[切片] = 可迭代对象
    说明：
      切片赋值的赋值运算符(=)的右侧必须是一个可迭代对象
    示例：
      L  = [2, 3, 4]
      L[0:1] = [1.1, 2,2]    # [1.1, 2.2, 3, 4]
      L[0:0] = [1]           # [1, 1.1, 2.2, 3, 4]
      L[1:3] = []            # [1, 3, 4]

      L  = [2, 3, 4]
      L[1:2] = "AB"          # [2, 'A', 'B', 4]
      L[1:3] = range(7,10)   # [2, 7, 8, 9, 4]
    切片的注意事项：
      对于步长不等于1的切片赋值，赋值运算符的右侧可迭代对象提供的元素
      的个数，一定要等于切片切出的段数

      L = [1, 2, 3, 4, 5, 6]
      L[::2] = "ABC"     # ['A', 2, 'B', 4, 'C', 6]
      L[::2] = "ABCD"    # Value Error
      
-del语句
  可以用于删除列表的元素
  语法：
    del 列表[整数表达式]
    del 列表[切片]
  示例：
    L = [1, 2, 3, 4, 5, 6, 7, 8]
    del L[-1]   # [1, 2, 3, 4, 5, 6, 7]
    del L[1::2] # [1, 3, 5, 7]
  练习：(见test 1)
    已经有列表：
      L = [3, 5]
    用索引和切片操作，将原列表改变为：
      L = [1, 2, 3, 4, 5, 6]
    将列表反转，结果如下：
      L = [6, 5, 4, 3, 2, 1]
    然后删除最后一个元素，结果如下：
      L = [6, 5, 4, 3, 2]
练习：(见test 2)
  写一个程式，让用户输入很多个正整数，当输入负数时，结束输入
  将用户输入的数字存储于列表中，
  1.打印存有数字的列表
  2.求出这些数字中的平均数
  3.求出这些数字中的最大数

-python3中常用于序列的函数
  len(x)  返回序列的长度
  max(x)  返回序列的最大值元素-->x为一个对象时，该对象需为可迭代对象；x也可为一个以上的对象，如：max(3,5,7,8)
  min(x)  返回序列中最小值函数
  sum(x)  返回序列中所有元素的和(元素必须是数字类型)
  any(x)  真值测试，如果列表中的一个值为真值，返回true
  all(x)  真值测试，列表中所有值都为真值，才返回true
-python3中常见的列表方法(method)
  文档参见：
    python_base_docs_html  list.html

    L.index(v [, begin[, end]]) 	返回对应元素的索引下标, begin为开始索引，end为结束索引,当 value 不存在时触发ValueError错误
    L.insert(index, obj) 	        将某个元素插放到列表中指定的位置
    L.count(x) 	                  返回列表中元素的个数
    L.remove(x) 	                从列表中删除第一次出现在列表中的值
    L.copy() 	                    复制此列表（只复制一层，不会复制深层对象)
    L.append(x) 	                向列表中追加单个元素
    L.extend(lst) 	              向列表追加另一个列表
    L.clear() 	                  清空列表,等同于 L[:] = []
    L.sort(reverse=False) 	      将列表中的元素进行排序，默认顺序按值的小到大的顺序排列
    L.reverse() 	                列表的反转，用来改变原列表的先后顺序(直接改变原列表,而不是返回反转后的列表)
    L.pop([index]) 	              删除索引对应的元素，如果不加索引，默认删除最后元素，同时返回删除元素的引用关系(即可以赋值给变量，如：v = L.pop(2))

  练习：(见test 3)
    写一个程式，让用户输入很多个正整数，当输入负数时结束
    1)打印这些数中最大的数
    2)打印这些数中第二大的数
    3)删除最小的一个数

-深拷贝(deep copy)和浅拷贝(shallow copy)
  浅拷贝
    浅拷贝是指在复制过程中，只复制一层变量，不会复制深层
    变量绑定的对象的复制过程
  如：
   L = [3.1, 3.2]
   L1 = [1, 2, L]  # L1 = [1, 2, [3.1, 3.2]]
   L2 = L1.copy()  #浅拷贝 L2 = [1, 2, [3.1, 3.2]]，但列表内嵌套的[3.1, 3.2]并没有复制，而是原来L绑定的对象，如下一步
   L2[2][0] = 0    #这时改变L2内嵌套的列表还会改变L,这时L = [0, 3.2]  L1=[1, 2, [0, 3.2]]
   
  深拷贝
    如：
    import copy   #导入复制模块
    L = [3.1, 3.2]
    L1 = [1, 2, L]
    L2 = copy.deepcopy(L1)  #深拷贝
    print(L1)    #[1,2,[3.1,3.2]]
    print(L2)    #[1,2,[3.1,3.2]]
    L2[2][0] = 0
    print(L1)    #[1,2,[3.1,3.2]]
    print(L2)    #[1,2,[0,3.2]]

  ??
  s = "ABC"
  l = [1, 2, s]
  l2 = l.copy()
  s = "abc"
  print(l)   #??为什么是[1, 2, 'ABC']  答：因为字符串为不可变对象，第二步时l已经=[1,2,"ABC"]，而不再是[1,2,s]所以改变s,不会对l有影响
  print(l2)  #??为什么是[1, 2, 'ABC']

-列表与字符串比较
  1.列表和字符串都是序列，元素之间有先后顺序关系
  2.列表和字符串有相同的操作: + += * *= < > in ...
  3.字符串是不可变化的序列，列表是可变序列
  4.字符串的每个元素只能存储字符，而列表可以存储任意类型的元素
  5.列表和字符串都是可迭代对象
  
-字符串的文本解析方法 split 和 join
  S.split(sep=None)  
    将字符串使用spe作为分隔符分隔s字符串，返回分割后的字符串列表
    当不给定参数时，用空白字符作为分隔符
  S.join(可迭代对象)   #括号内可以是列表也可以是字符串或其他可迭代对象(元素必须是字符串类型)
    用可迭代对象中的字符串生成一个中间用s进行分隔的字符串
  
  示例：
    s = "Beijing is capital"
    L = s.split(" ")         #L = ['Beijing', 'is', 'capital'] 返回的是列表，分隔符不保留
    L = s.split("i")         #['Be', 'j', 'ng ', 's cap', 'tal']  分隔符不保留
    s = "Beijing is       capital"
    L = s.split()         #['Beijing', 'is', 'capital']  默认值是以空白字符做分隔符

    L = ["Beijing", "is", "capital"]
    s = " ".join(L)       # s = "Beijing is capital"    返回的是字符串对象
    s = "#".join(L)       # s = "Beijing#is#capital"    返回的是字符串对象

  练习：
    有字符串"hello"
    生成新的字符串：
      "h e l l o"和"h-e-l-l-o"
    答：
      s = " ".join("hello")     #"h e l l o"
      s = "-".join("hello")     #"h-e-l-l-o"

-列表推导式 list comprehesion
  列表推导式是用可迭代对象创建列表的表达式

  作用：
    创建列表
  语法：
    [表达式 or 变量 in 可迭代对象]
    或
    [表达式 for 变量 in 可迭代对象 if 真值表达式]
  示例：
    生成一个数值为1~9的平方的列表
    L = [x**2 for x in range(1,10)]                  #L = [1, 4, 9, 16 ... 64, 81]

    生成一个数值为1~9的奇数的平方的列表
    L = [x**2 for x in range(1,10) if x % 2 != 0]    #L = [1, 9, 25, 49, 81]
-列表推导式的嵌套
  [表达式 
      for 变量1 in 可迭代对象1 if 真值表达式1
          for 变量2 in 可迭代对象2 if 真值表达式2
              ....]
  如：
  L = [x + y for x in "ABC" for y in "123"]
  #L = ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3', ]

练习：
  1.有一些数存于列表中，如：
    L = [1, 3, 2, 1, 6, 4, ... 98, 2] #任意
    1)将列表中出现的数字存入另一个列表L2中
      要求：
        重复出现多次的数字只能在L2中保留一份(去重)
    2) 将列表中出现两次的数字存于L3列表中,在L3列表中只保留一份

  2.生成一个列表,求x的平方+1的列表，跳过结果能被5整除的数
    (0 <= x <= 100)x是整数
  3.把 0~100 之间的所有素数存于一个列表中(素数:只能被1和本身整除的大于1的正整数)
    即：
      L = [2, 3, 5, 7, 11, ... 97]
  4.ftp 上otc_ext.txt的习题
    练习1：
      利用列表推导式，生成一个包含多个不同精度的pi，列表如下：
      [“3.1”, “3.14”, “3.142”, “3.1416”, “3.14159”]
      from math import pi #从math库里导入pi

    练习2：
    import random
    random.randint(m,n) # 随机生成m-n之间的一个整数
    利用上面函数随机生成一个6位的验证码，
    要求：
    验证码只能有大小字母及数字组成((数字ASCII 48~57)(大写字母ASCII 65~90,小写字母97~122 ))
    6位验证码不能重复

--------------------------------------------------------------------------------------------------------
**************************** 2018年10月12日  星期五 晴   day07********************************************
-元组 tuple
  元组是不可变的序列，同list一样，元组是可以储存任意类型的数据的容器

  元组的表示方法：
    用小括号()括起来，单个元素括起来后加逗号(,)区分单个对象还是元组
  创建空元组的字面值：
    t = ()   #创建一个空元组，用t绑定
  创建非空元组的字面值
    t = 200,     #创建一个只有一个数字200的元组
    t = (200,)
    t = (1,2,3)
    t = 100, 200, 300

    创建元组的错误示例：
      t = (20)  #t绑定的是整数20，不是元组
      x,y,z = (100, 200, 300)  # 序列赋值,type(x) --> int
      x,y,z = 100, 200, 300    # 等同于x,y,z = (100, 200, 300)
      x,y,z = [100, 200, 300]  # 等同于x,y,z = (100, 200, 300)
      x,y,z = "ABC"            # 序列赋值，不是元组
      x, y = y, x              # 可以用序列赋值交换两个变量的绑定值

-type()函数
  s = "ABC"
  type(s) --> str

  判断类型时，不能用==，要用is 或is not,例：
    if type(s) is str:
        ....

-元组的构造函数
  tuple()            生成一个空的元组，等同于()
  tuple(interable)   用可迭代对象生成一个新的元组

  示例：
    t = tuple()
    t = tuple("ABC")         # ('A', 'B', 'C')
    t = tuple(range(1,10,3))

-元组的运算
  +  +=  *  *=
  t = (1, 2, 3,) + (4, 5, 6)  # (1, 2, 3, 4, 5, 6)

  t = (1, 2, 3)
  t += (4, 5, 6)   # (1, 2, 3, 4, 5, 6) 但是id已经与原来的t不同，因为元组是不可变序列
  t = (1, 2) * 3   # (1, 2, 1, 2, 1, 2)

  比较运算：
    < <= > >= == !=
    比较规则与列表的比较规则完全相同
  in / not in 运算符
      等同于列表的in / not in 运算符
  索引 和 切片
    索引取值和切片取值的规则与列表完全相同
    注：元组不支持索引赋值和切片赋值

-元组的方法：
  参见 python_base_docs_html/ tuple.html
  t.count()
  t.index()

-序列相关的函数也能用于元组中
  len(x), max(x), min(x)
  sum(x), any(x), all(x)

-字典 dict
    1.字典是一种可变的容器，可以存储任意类型的数据
    2.字典中的每个数据都是用"键"(key)进行索引的，而不像序列(str,list,tuple)
      可以用整数索引
    3.字典中的数据没有先后顺序关系，字典的存储是无序的(像彩票箱，垃圾篓，都是无序的容器)
    4.字典中的数据以"键(key)-值(value)对"的形式进行存储
    5.字典的键不能重复，且只能用不可变类型作为字典的键
  创建字典的字面值方式：
    字典的表示方式以{}括起来，以冒号(:)分隔键值对，各键值对之间用逗号分隔开
    创建空字典：
      d = {}
    创建非空字典：
      d = {"姓名": "tarena", "年龄": 35}
      d = {"one": 1, "two": 2}
      d = {1: "one", 2: "二", 3: [1, 2, 3]}  
  创建字典的构造函数 dict:
    dict()   #生成一个空的字典
    dict(interable)   #用可迭代对象创建一个，但该可迭代对象要形成键值对
                      如L = [(1, 2), [3, 4], "AB"]这种，一个作键一个作值
    dict(**kwargs)    #关键字传参形式生成一个字典

    示例：
      L = [(1, 2), [3, 4], "AB"]
      d = dict(L)      # {1: 2, 3: 4, 'A': 'B'}
      d = dict(name="tarena", age= 15)
            # d = {'age':15, 'name': 'tarena'}  关键字传参形式
              但是传参=号前的值必须符合变量名的命名规则，生成的字典
              键是字符串
  字典的键必须为不可变类型
    python中可变类型有4种：
      list(列表), dict(字典), set(集合), bytearray(字节数组)

-字典的基本操作
  字典的键索引:
    语法：
      字典[键]
    作用:
      用键获取字典中该键对应的值
    示例：
      d = {'name': 'tarena', 'age': 16}
      print(d['name'], "的年龄是", d['age'])
  添加和修改字典的元素：
    语法：
      字典[键] = 值
    说明：
      键不存在时，创建键，并让键绑定对应的值
      键存在时，修改键绑定的值
    示例：
      d = {}
      d['name'] = '小张'  # 添加一个键值对
      d['年龄'] = 20
      d['年龄'] += 1      # 修改'年龄'键对应的值
练习：(见test 1)
  写一个程序，让用户分两次输入一个人的信息：
      信息包含： 姓名 和 电话号码
    让用户输入多个人的信息，当输入姓名为空时结束输入
    把数据存于字典中
      姓名作键为键，电话号码作为值
    最后打印存储数据的字典  

-删除字典元素
    del 语句
  语法：
    del 字典[键]
  示例：
    d = dict(name="小张", age=20)
    del d['age']
    print(d)           #{'name': '小张'}

-字典的键判断  in / not in 运算符
    可以用in运算符判断一个键是否存在于字典中，如果存在则返回True，否则
    返回False(只能判断键，不能判断值)
  例如:
    d = {'name': 'tarena', 'age': 15}
    'name' in d     #true
    15 in d         #False
  练习：(见test 2)
    写一个程式，实现以下需求：
      1.将如下数据形成一个字典 seasons
        键    值
        1     '春季有1,2,3月'
        2     '春季有4,5,6月'
        3     '春季有7,8,9月'
        4     '春季有10,11,12月'
      2.让用户输入一个整数代表这个季度，打印这个季度对应的信息，如果用户输入
        的信息不存在于字典内，则提示用户'信息不存在'

-字典的迭代访问
  字典是可迭代对象，字典只能对键进行迭代访问
  
  示例：
    d = {0:'零', 5:'伍', 1:'壹', 2:'贰'}
      for n in d:
          print(n)    #0, 1, 2, 5

-可以用于字典的函数：
  len(x)    返回字典的键值对的个数
  max(x)    返回字典的键的最大值
  min(x)    返回字典的键的最小值
  sum(x)    返回字典的所有键的和
  any(x)    真值测试，只对键进行测试
  all(x)    真值测试，所有键都为真，返回True

-字典的方法
  文档参见：
    python_base_docs_html/ dict.html
    D.clear() 	              清空字典
    D.pop(key) 	              移除键，同时返回此键所对应的值
    D.copy() 	                返回字典D的副本,只复制一层(浅拷贝)
    D.update(D2) 	            将字典 D2 合并到D中，如果键相同，则此键的值取D2的值作为新值
    D.get(key, default=None) 	返回键key所对应的值,(如果没有此键，则返回default的值，不会报错)
                              default值可以自定义，如D.get(key,"您要的东西不存在")

    D.keys() 	                返回可迭代的 dict_keys 集合对象
    D.values() 	              返回可迭代的 dict_values 值对象
    D.items() 	              返回可迭代的 dict_items 对象
    示例：
      d = {0:'零', 5:'伍', 1:'壹', 2:'贰'}
      d.items()           #[(0, '零'), (1, '壹'), (2, '贰'), (5, '伍')]
      for k, v in d.items():
          print("键是", k, '值是', v)
  练习：(见test 3)
    输入一段字符串，打印出这个字符串中出现过的字符及出现过的次数
      如：
        输入：abcdabcaba
      打印如下：
        a: 4次
        b: 3次
        c: 2次
        d: 2次
      注：不要求打印顺序

-字典推导式
    用可迭代对象来创建字典的表达式
  语法：
    {键表达式: 值表达式 for 变量 in 可迭代对象 [if 真值表达式]}
    注：[]的内容可以省略
        for 也可以嵌套，语法同列表推导式嵌套
  示例：
    生成一个字典:键为数字0~9,值为键的平方
    #{x: x**2 for x in range(10)}

  练习：（见test 4）
    L = ['Tarena', 'XiaoZhang', 'XiaoWang']
  生成如下字典：
    d = {'Tarena':6, 'XiaoZhang':9, 'XiaoWang':8}  #值是键的长度

  练习：(见test 5)
    Nos = [1001, 1002, 1005, 1006]
    names = ['Tom', 'Jerry', 'Spike', 'Tyke']
    试生成如下字典:
      d = {1001:'Tom', 1002: 'Jerry', 
          1005: 'Spike', 1006: 'Tyke'}

-字典 VS 列表
  1.都是可变的容器
  2.索引方式不同，列表用整数索引，字典用键索引
  3.列表的存储是有序的，字典的存储是无序的
  4.字典的插入，删除，修改的速度可能会快于列表(重要)

-练习
  1.生成前40个斐波那契数列(Fibonacci 数列)
    1 1 2 3 5 8 13 ...
    要求：将这些数存入列表中
    最后打印这些数
  2.有一只小猴子，摘了很多桃，
    第一天吃了全部的桃子的一半，感觉吃不饱又吃了一个
    第二天吃了剩下的一半，感觉不饱又吃了一个
    以此类推...
    到第10天，发现只剩下一个了
    问：第一天摘了多少桃子？
  3.打印九九乘法表
    1x1=1
    1x2=2 2x2=4
    1x3=3 2x3=6 3x3=9
    ...
    .................. 9x9=81
  4.任意输入很多个学生的姓名，年龄，成绩，每个学生的信息存入到字典中，
    然后再放在列表内
    每个学生的信息需要手动输入：
      如：
        请输入姓名：tarena
        请输入年龄：15
        请输入成绩：99
        ...
        ...
        请输入姓名：<回车> 结束输入
      内存存入格式：
        infos = [{'name':'tarena', 'age':15, 'score':99}, ... ...]
      1.打印以上的列表
      2.按如下表格打印学生的信息
      +-----------+----------+----------+
      |   姓名    |    年龄   |   成绩   |
      +-----------+----------+----------+
      |   tarena  |    15    |    99    |
      |   china   |    70    |    98    |
      +-----------+----------+----------+

---------------------------------------------------------------------------------------------------------
**************************** 2018年10月13日  星期六 晴   (自习)********************************************

#pyqt5 界面语言

-------------------------------------------------------------------------------------------------------
**************************** 2018年10月15日  星期一 晴  day08********************************************
-集合 set
    集合是可变的容器
    集合内的数据对象都是唯一的(不能重复出现)(有天然去重的功能)
    集合是无序的存储结构，集合中的数据没有先后关系
    集合内的元素必须是不可变对象(不能是列表、字典、集合)   
    集合是可迭代的
    集合相当于只有键没有值的字典
  创建集合的构造函数
    set()  创建一个空的集合对象(不能用{}来创建空集合)
    set(interable)  用可迭代对象来创建新的集合对象
  示例：
    s = set()            # s 绑定空集合
    s = set(range(1,5))  # s = {1, 2, 3, 4}
    s = set("hello")     # s = {'l', 'h', 'o', 'e'}  (天然去重'l')
    注：
      非空集合用{}括起来，内部的各个元素用逗号(,)分隔开
  字面值的方式来创建非空集合
    s = {1,2,3,4}                      #不能用{}来创建空集合，{}创建的是空字典
    s = set{"ABCCBA"}                  # S = {'A', 'B', 'C'}
    s = set({1:'一', 3:'三', 3:'八'})   # s = {1,3,8}  因为字典是可迭代对象，能够迭代提供其键

-集合的运算
  交集 &  并集|  补集-  对称补集 ^  子集<  超集>

  - 生成两个集合的补集
    s1 = {1,2,3}
    s2 = {2,3,4}
    s3 = s1 - s2  #生成属于S1但不属于S2的所有元素的集合
    # s3 = {1}
  ^ 生成两个集合的对称补集
    s1 = {1,2,3}
    s2 = {2,3,4} 
    s3 = s1 ^ s2  #s3 = {1, 4} 相当于(s1-s2)|(s2-s1)
  < 判断一个集合是否是另一集合的子集
  > 判断一个集合是否是另一集合的超集
    s1 = {1,2,3}
    s2 = {2,3}
    s2 < s1   #true 被包含的集合即为子集
    s1 > s2   #true 包含子集的集合即为该子集的超集
  == != 判断集合是否相等
  >= <= (略)
  in / not in 运算符
  
-集合和字典的优点
  in / not in 运算速度比较快

-能用于集合的內建函数
  len(x)
  max(x)
  min(x)
  sum(x)
  any(x)
  all(x)
练习：(见test 1)
  经理有：曹操，刘备，孙权
  技术员有：曹操，孙权，张飞，关羽
  用集合求：
    1.既是经理又是技术员的有谁？
    2.是经理，但不是技术员的人有谁？
    3.是技术员，但不是经理的人有谁？
    4.张飞是经理吗？
    5.身兼一职的人都有谁？
    6.经理和技术员共有几个人？
-集合的方法：
  S.add(e) 	                          在集合中添加一个新的元素e；如果元素已经存在，则不添加
  S.remove(e) 	                      从集合中删除一个元素，如果元素不存在于集合中，则会产生一个KeyError错误
  S.discard(e) 	                      从集合S中移除一个元素e,在元素e不存在时什么都不做;
  S.clear() 	                        清空集合内的所有元素
  S.copy() 	                          将集合进行一次浅拷贝
  S.pop() 	                          从集合S中删除一个随机元素;如果此集合为空，则引发KeyError异常
  S.update(s2) 	                      等同于S1 = s2, 用 S与s2得到的全集更新变量S
  S.difference(s2) 	                  S - s2补集运算，返回存在于在S中，但不在s2中的所有元素的集合
  S.difference_update(s2) 	          等同于 S -= s2
  S.intersection(s2) 	                等同于 S & s2
  S.intersection_update(s2) 	        等同于S &= s2
  S.isdisjoint(s2) 	                  如果S与s2交集为空返回True,非空则返回False
  S.issubset(s2) 	                    如果S与s2交集为非空返回True,空则返回False
  S.issuperset(...) 	                如果S为s2的子集返回True,否则返回False
  S.symmetric_difference(s2) 	        返回对称补集, 等同于 S ^ s2
  S.symmetric_difference_update(s2) 	等同于 S ^= s2, 用 S 与 s2 的对称补集更新 S
  S.union(s2) 	                      生成 S 与 s2的全集, 等同于 S \

-集合推导式
  集合推导式是用可迭代对象创建集合的表达式

  语法：
    {表达式 for 变量 in 可迭代对象 [if 真值表达式]}
    注：[]  代表其中的内容可忽略
  语法：
    L = [1, 1, 2, 2, 3, 3]
    s = {x**2 for x in L}   #s = {1, 4, 9}，自动去重
  集合推导式的嵌套：
    等同于列表推导式嵌套

-固定集合(frozenset)
    固定集合是不可变的，无序的，含有唯一元素的集合
  作用：
    固定集合可以作为字典的键，还可以作为集合的值
  固定集合的构造函数 frozenset
    frozenset()           创建一个空的固定集合
    frozenset(interable)  用可迭代对象创建一个新的固定集合
  示例：
    fz = frozenset()
    fz = frozenset("hello")  #fz = frozenset({'l', 'h', 'o', 'e'})

-固定集合的运算：
  交集& 并集| 补集- 对称补集^
  in /not in 运算符
  < <= > >= == !=
  (以上运算符用法等同于set中的用法)

-固定集合的常用方法
  等同于集合的全部方法(不包含修改集合的方法)


---------------------第一阶段结束，阶段性总结---------------------
----------------------------------------------------------------
  数据类型：
    不可变的数据类型：
      bool, int, float, complex, str, tuple
      frozenset, bytes(字节串，后面学)
    可变的数据类型：
      list, dict, set, bytearray(字节数组，后面再学)
  值：
    None, False, True
  运算符：
    + - * / // % **
    > >= < <= == !=
    in / not in
    is / is not
    not and or
    & | ^
    +(正号)  -(负号)
  表达式：
    1
    True
    1 + 2 * 3
    print()   #函数调用表达式
    L.pop(2)  #方法调用表达式
    条件表达式：
      x if x > y else y
    全部的推导式：列表、字典、集合
  语句：
    表达式语句(表达式单独在一行可以形成表达式语句)
      print()  
      "这是一段文字"
    赋值语句：
      a = 100
      a = b = c = 200
      x, y, z, = 1, 2, 3
    del 语句
    if 语句
    while 语句
    for 语句
    break 语句
    continue 语句
    pass 语句
  內建函数：
    len(x)
    max(x)
    min(x)
    sum(x)
    any(x)
    all(x)
    ------构造函数------
    bool(x)
    int(x)
    float(x)
    complex(x)
    str(x)
    list(x)
    tuple(x)
    dict(x)
    set(x)
    frozenset(x)
    ------数值函数------
    abs(x)
    round(x, y)
    pow(x,y,z=None)
    range(star,stop,step)
    ------字符串函数------
    bin(x)
    oct(x)
    hex(x)
    chr(x)
    ord(x)
    ----基本输入输出函数----
    input(x)
    print(x)
    --------------------
    id(x)
    type(x)
----------------------------------------------------------------
----------------------------------------------------------------

-函数(function)(函数三要素:参数、功能、返回值)
    函数是可以重复执行的语句块，可以重复调用并执行
    函数是面向过程编程的最小单位
  作用：
    用于封装语句块，提高代码的重用性
    定义用户级别的函数
    提高代码的可读性和易维护性
  

-def 语句
  语法：
    def 函数名(形参列表):
        语句块
  作用：
    创建一个函数，将语句块打包，用函数名绑定，以备调用
  说明：
    1.函数名的命名规则与变量的命名规则相同(只能以字母或下划线开头)
    2.函数名是一个变量，它用来绑定函数
    3.函数有自己的名字空间，在函数外部不可以访问函数内部的变量，
      在函数内部可以访问函数外部变量，但不能对外部的变量赋值(如果先访问了外部变量，再对
      其进行赋值会出错；如果没有访问外部变量，而是创建了一个与外部变量同名的变量，则该
      变量会判定为内部变量)
    4.语句部分不能为空，如果为空需要填充pass语句
    5.函数如果不需要传入参数，形参列表可以为空

-函数调用
  语法：
    函数名(实际调用传递参数)
  说明：
    函数调用是一个表达式
    如果函数内部没有return语句，函数执行完毕后返回None
  示例见：
    test 2
练习1：
  1.写一个函数myadd,此函数中的参数列表里有两个参数x、y,此函数的功能
    是打印 x + y 的和  (答见test 3)
  2.写一个函数print_even,传入一个参数n代表终止整数，打印2 4 6 8 ... n之间所有
    偶数(包含n)  (答见test 4)
    函数定义如下：
      def print_even(n):
          ....
      print_even(8)
      #打印：
      2
      4
      6
      8

-return 语句
  语法：
    return [表达式]
    注： [] 代表可以省略
  作用：
    用于函数中，结束当前函数的执行，返回到调用函数的地方，同时返回一个对象的引用
    关系
  说明：
    1.return 语句后跟的表达式可以省略，省略后相当于 return None
    2.函数内部没有return 语句，则函数执行完最后一条语句后返回None(相当于在最后
      加了一条return None 语句)
  练习：
    1.写一个函数mymax,实现返回三个数的最大值：(答见test 5)
      如 def mymax(a,b,c)
          ....
         print(mymax(100,200,300))  #300
         print(mymax("ABC",'abc','123'))
    2.写一个函数myadd，给出两个数，返回两个数的和
      如：  (答见test 6)
        def myadd(x,y):
            ...
        a = int(input("请输入第一个数："))
        b = int(input("请输入第二个数："))
        print("您输入的两个数的和是：",myadd(a,b))
    3.写一个函数input_number  (答见test 7)
      def input_number():
          ...
      此函数用来获取用户循环输入的整数，当输入负数时结束，将用户输入的数字
      以列表的形式返回，再用內建函数max,min,sum求出用户输入的数的最大值、
      最小值及和,如：
        L = input_number()
        print("最大数是：",max(L))
        print("最小数是：",min(L))
        print("和是：",sum(L))
练习：
  1.创建两个函数
    def sum3(a,b,c):
        #用于返回三个数的和
        ...
    def pow3(x)
        #用于返回x的三次方
        ...
    用以上两个函数计算：
      1.计算1的立方 + 2的立方 + 3的立方的和
      2.计算1+2+3的和的立方
  2.改写之前的学生信息管理程序，封装为两个函数：
    def input_student():
        #此函数用于返回所有用户输入的学生信息的列表
    def output_student(L):
        #此函数以表格形式打印学生信息
    以下是调用：
    infos = input_student()
    print(infos)
    output_student(infos)
  3.编写函数，计算下列多项式的和：
    Sn = 1/(1*2) + 1/(2*3) + 1/(3*4) + ... + 1/(n*(n+1))
    def Sn(n):
        ...
    print(Sn(3))    # 0.75
    print(Sn(1000)) 

-------------------------------------------------------------------------------------------------------
**************************** 2018年10月16日  星期二 小雨  day09********************************************
函数的传参(把数据给函数)
函数的形参(接收函数调用传过来的数据)
-python 函数的参数传递
  传递方式：
    1.位置传参
          实际参数(实参)的对应关系与形式参数(形参)的对应关系是按位置来依次对应的
        说明：
          实参和形参通过位置进行传递和匹配
          实参个数必须与形参的个数相同
        例：(见 test 1)
          def fa(a,b,c):
              ...
          fa(1,2,3)  #调用时实参与形参按位置一一对应
      1.1 序列传参 (见 test 2)
          序列传参是指在函数调用过程中，用*(星号)将序列拆散后，按位置进行传递的
          传递方式
        说明：
          序列传参是，序列拆解的位置将与形参一一对应
    2.关键字传参
          关键字传参指传参时，按照形参名称给形参赋值
          实参和形参按名称进行匹配
        说明：
          可以不按位置进行匹配
        例：(示例见 test 3)
          print(1,2,3,sep='')  # sep 的传参就是典型的关键字传参，与其所在位置无关
      2.1 字典关键字传参
          是指实参为字典，将字典用**拆解后进行关键字传参的传递方式
        说明：
          字典的键名和形参名必须一致
          字典的键名必须为符合标识符命名规则的字符串
          字典的键名要在形参中存在
        示例： (见 test 4)

-函数的综合传参
    1.函数的传参方式在能确定形参能唯一匹配到相应实参的情况下，可以任意组合
    2.函数的位置传参要先于关键字传参
  示例：
    def myfun(a, b, c):
        pass
    myfun(100, *[200, 300])             #合法,位置传参和序列传参组合
    myfun(*"AB", 100)                   #合法,序列传参和位置传参组合
    myfun(100, c=300, b=200)            #合法,位置传参和关键字传参组合
    myfun(100, **{"c":300, "b":200})    #合法,位置传参和字典关键字传参组合
    myfun(c=300, 100, b=200)            #错误!!! 位置传参必须在关键字传参之前
  练习： (见test 5)
    写一个函数，传入三个参数，返回这三个参数中的最大值和最小值元素
    结果要求：
      形成元组，最小值在前，最大值在后，返回给调用者
    如：
      def minmax(a, b, c):
          ...
      t = minmax(300,100,200)
      print(t)  #(100,300)

-----------------------------------------以下内容是函数形参-----------------------------------------------
-函数的缺省参数
  语法：
    def 函数名(形参名1=默认实参1, 形参名2=默认实参2, 形参名3=默认实参3,...)
  作用：
    让函数的调用者少传递参数时实现默认功能
  示例：
    def info(name, age=1, address="不详"):
        print(name,'今年', age, '岁，家庭地址',address)
    info("水电费",35,"北京市朝阳区")  # 水电费 今年 35 岁，家庭地址 北京市朝阳区
    info("水电费")                   # 水电费 今年 1 岁，家庭地址 不详
    info()                          # 报错!!! name没有缺省参数
  说明：
    1.缺省参数必须自右向左依次存在，如果一个参数有缺省参数，则其右侧的参数都必须有
      缺省参数
    2.缺省参数可以有0个，1个或多个，甚至全部都有缺省参数
  如：
    def fn(a, b=10, c):    #错误
    def fn(a=0, b=None, c=False):  #合法
  练习：(见 test 7)
    写一个函数，myadd,此函数可以传入二个,三个或四个实参，此函数的功能是：
    计算所有实参的和
    如：
      def myadd(...):
          ...
      print(myadd(10,20))        #30
      print(myadd(100,200,300))  #600
      print(myadd(1, 2, 3, 4))   #10

-函数的可变实参和不可变实参的传递
  示例：
    L = [1,2,3]
    def f1(L):
        L = [4,5,6]     #但是如果此处改写成L.append(4),或+=,则会改变外部的L
        print(L)
    f1(L)     # [4,5,6] 过程：外部L[1,2,3]传进f1, 内部L绑定外部[1,2,3] ,内部L被赋予[4,5,6]，该赋值与外部L无关
    print(L)  # [1,2,3] 函数内部的赋值过程，不会改变外部变量的绑定关系
  说明：
    当一个可变对象通过函数实参传入函数时，在函数内部可以通过局部变量来操作可变
    对象(列表，字典，集合...)
  
面试题：
  试运行以下程序的结果是什么，为什么？
    L = [1,2]
    def fn(a,lst=[]):
        lst.append(a)
        print(lst)
    fn(3,L)  #[1,2,3]
    fn(4,L)  #[1,2,3,4]
    fn(5)    #[5]
    fn(6)    #[5,6]
    fn(7)    #[5,6,7]

    改写
    L = [1,2]
    def fn(a,lst=[]):
        if lst is None:
            lst =[]
        lst.append(a)
        print(lst)
    fn(3,L)  #[1,2,3]
    fn(4,L)  #[1,2,3,4]
    fn(5)    #[5]
    fn(6)    #[6]
    fn(7)    #[7]

-函数形参的定义方式
    位置形参
    星号元组形参
    命名关键字形参
    双星号字典形参
  -位置形参：
    语法：
      def 函数名(形参变量1,形参变量2,...):
          ...
  -星号元组形参(实现不定传参)：
    语法：
      def 函数名(*元组形参名):
          ...
    作用：
      收集多余的位置传参
    说明：
      元组形参名一般命名为'args'(args绑定一个元组)
      *元组形参一个函数只能有一个
    示例：
      def func(*args):
          print("实参的个数是:",len(args))
          print("args=",args)
      func()             #合法
      func(1,2,3,4)      #可以任意数量位置传参
      func(a=100,b=100)  #错误!!! 只能收集位置传参
    练习(见test 8)：
      写一个程式，mysum，可以传入任意个实参的参数，此函数的功能是返回所有
      实参的和：
        def mysum(*args):
            ...
        print(mysum(1,2,3,4))  #10
        print(mysum(1,2,3))    #6
  -命名关键字形参
    语法：
      def 函数名(*,命名关键字形参1,命名关键字形参2,...)：
          ...
      或：
      def 函数名(*args,命名关键字形参1,命名关键字形参2,...)：
          ...
    作用：
      强制所有的命名关键字形参都必须用关键字传参或字典关键字传参
    示例：
      def func(a,b,*,c,d):  #强制c/d必须用关键字传参
          print(a, b, c, d)

      func(1,2,3,4)      #传参失败
      func(1,2,c=30,d=40) #传参合法

     例2：
      def func(a,b,*args,c,d):  #强制*args后的所有形参必须用关键字传参
          print(a, b, args, c, d)

      func(1,2,3,4)            #传参失败
      func(1,2,c=30,d=40)      #传参合法 -->  1, 2, (), 30, 40
      func(1,2,3,4,5c=30,d=40) #传参合法 -->  1, 2, (3,4,5), 30, 40
    练习：
      1.思考print()函数的形参列表是如何定义的(见test9)
      2.已知內建函数max 的帮助文档为：(见test10)
        max(...)
          max(iterable) --> value
          max(arg1,arg2,*args)  -->value
        仿造max函数，写一个与max功能完全一样的mymax函数，
        (不允许调用內建的max)
        如：
          def mymax(...):
              ...
          print(mymax([6, 8, 3, 5]))   #8
          print(mymax(100, 200))       #200
          print(mymax(1,3,5,9,7))      #9
          print(mymax())               #报错
  -双星号字典形参
    语法：
      def 函数名(**字典形参名):
          语句块
    作用：
      收集多余的关键字形参
    说明：
      字典形参名一般命名为'kwargs'(kwargs绑定字典)
      一个函数内字典形参最多只有一个
    示例：
      def func(**kwargs):
          print("关键字传参的个数是：",len(kwargs))
          print("kwargs=",kwargs)
      func(name="魏老师", age=35, address="朝阳区")

-函数的形参说明：
  1.位置形参，缺省参数，星号元组形参，命名关键字形参，双星号字典形参可以混合使用
  2.函数形参自左至右的定义顺序为：
    位置形参
    星号元组形参
    命名关键字形参
    双星号字典形参
    示例：
      def fn(a, b, *args, c, **kwargs):
          pass
      fn(1,2,3,4,c=30,d=40,e=50)

-函数的不定长参数
  有两种：星号元组形参，双星号字典形参
  用不定长参数可以接收任意的传参
  如：
    def fn(*args, **kwargs):
      print(args,kwargs)

-全局变量和局部变量
  局部变量
    1.定义在函数内部的变量称为局部变量(函数的形参也是局部变量)
    2.局部变量只能在函数内部使用
    3.局部变量在函数调用时才能创建，在函数调用后会自动销毁
  全局变量
    1.定义在函数外部，模块内部的变量称为全局变量
    2.全局变量所有的函数都可以直接访问(但函数内部不能将其直接赋值)
  说明：
    在函数内部赋值语句不会对全局变量造成影响

-练习：
  1.写一个函数get_chinese_char_count(s),此函数的功能是给定一个字符串，
    返回这个字符串中中文字符的个数：
    如：
      def get_chinese_char_count(s):
          ...
      s = inpt("请输入中英文混合的字符串:")
      print("您输入的中文个数是",get_chinese_char_count(s))
      注：中文字符编码在0x4E00-0x9FA5之间
  2.写一个函数isprime(x),判断x是否为素数.如果为素数返回true,否则返回False
    如：
      print(isprime(3))  #True
      print(isprime(4))  #False
  3.写一个函数prime_m2n(m, n)返回从m开始,到n结束(不包含n)范围内的全部素数的列表，
    并打印对应的列表：
    如：
      L = prime_m2n(10,20)
      print(L) # [11,13,17,19]
  4.写一个函数primes(n) 返回指定范围内的全部素数(不包含n)的列表,打印这些素数的列表，
    如：
      L = prime(10)
      print(L)  #[2,3,5,7]
    1)打印100以内的素数
    2)打印200以内全部素数的和
  5.写一个myrange函数，参数可以传1~3个，实际含义与range函数规则相同，此函数返回符合
    range函数规则的列表
    如：
      L = myrange(4)
        print(L)  #[0,1,2,3]
      L = myrange(4,6)
        print(L)  #[4,5]
      L = myrange(1,10,3)
        print(L)  #[1,4,7]

---------------------------------------------------------------------------------------------------------
**************************** 2018年10月17日  星期三 小雨  day10********************************************
-globals()函数 和 locals函数
    globals()  返回当前全局作用域内变量的字典
    locals()   返回当前局部作用域内变量的字典
  示例：
    见test 1

-函数变量
    函数名是一个变量，它在创建函数时绑定该函数
  示例：
    def f1():
        print("f1函数被调用！")
    f2 = f1   #注意，不是f2 = f1() <<---没括号
    f2()      #　f1 函数被调用!
   ------------------------------------
    def f1():
        print("f1函数被调用！")
    f2 = f1()   #  此时f2绑定的是执行f1()后返回的值None
    f2()        #　报错,相当于执行了 None()

-一个函数可以作为另一个函数的实参传递
    可以把一个函数给另一个函数，另一个函数的形参变量将绑定
    实参函数
  示例：(另例2见test 4)
    def f1():
    print("f1函数被调用！")
    def f2():
        print("f2函数被调用!")
    def fx(fn):
        print("fn=",fn)
        fn()  #　调用fn()函数　"f1函数被调用!"
        fn()
    fx(f1)    #打印f1变量fn= <function f1 at 0x7fdd53a8ff28>
  练习：
    看懂如下代码，判断结果
      def myinput(fn):
          L = [1, 3, 9, 5, 7]
          return fn(L)

      print(myinput(max))  #9
      print(myinput(min))  #1
      print(myinput(sum))  #25

-函数可以作为另一个函数的返回值
  例：
  def get_function():
      s = input("请输入您要做的操作:")
      if s == "求最大":
          return max
      elif s == "求最小":
          return min
      elif s == "求和":
          return sum
  L = [2,4,6,8,10]
  fx = get_function()
  v = fx(L)
  print(v)

-练习：(见test 6)
  写一个计算公式的解释执行器
    定义以下函数
      def myadd(x,y):
          return x+y
      def mysub(x,y):
          return x-y
      def mymul(x,y):
          return x*y 
      ...
  有一个返回函数的函数
    def get_function(s):
        '''此函数功能是，传入一个字符串用s绑定，根据s的值返回上面
         相应的函数，如s=='+'或s=='加'，返回myadd''' 
  在主函数中程序如下:
    def main():
        while 1:
            s = input("请输入计算公式")  #如1加2
            L = s.split()   #L = ['1','加','2']
            a = int(L[0])
            b = int(L[2])
            fn = get_function(L[1])
            print("结果是:",fn(a,b))
    main()   

-函数调用之前要先定义好

-函数的嵌套定义
    函数嵌套定义是指一个函数里用def语句来创建其他函数的情况
  示例：
  def fn_outter():
    print("fn_outter被调用")
    def fn_inner():
        print("fn_inner被调用")
    print("fn_outter调用结束")
  fn_outter()  # 打印 "fn_outter被调用" "fn_outter调用结束"
  fn_inner()  #报错, inner是局部变量，但是如果内部用return fn_inner可以将其
               返回到函数外使用
            
-python的作用域
    作用域也叫名字空间，是访问变量时查找变量名的范围空间
  python中的四个作用域 LEGB
    作用域                            英文解释                    英文缩写
    局部作用域                     Local(function)                 L
    外部嵌套函数作用域              Enclosing Function local        E
    函数定义所在模块(文件)的作用域   Global(module)                  G
    Python內建模块的作用域          Builtin(python)                 B
  示例:
    v = 100
    def f1():
        v = 200
        print("f1.v=",v)
        def f2():
            v = 300            #如果没有此句，f2.v会打印200,即f2的外部嵌套函数作用域的v
            print("f2.v=",v)
        f2()
    f1()           # 200 300
    print("v=",v)  # 100

-变量名的查找规则
  L ---> E ---> G --> B
  注：
    在默认的情况下，变量名赋值会创建或改变当前作用域内变量的绑定关系

-global 语句
  作用：
    1.告诉解释执行器，global语句声明的一个或多个变量，这些变量的作用域为
      模块级的作用域，也称作全局变量
    2.全局声明(global)将赋值语句的变量映射到模块文件内部的作用域
  说明：
    1.全局变量如果要在函数内部被赋值，则必须经过全局声明
      (否则会被认为是局部变量)
    2.全局变量在函数内部不经过声明就可以访问(取值)
    3.不能先创建局部变量，再用global声明为全局变量，不符合规则
    4.global变量列表里的变量名不能出现在函数的形参列表里
  例：
  def fn(v):
      global v    # 报错,因为形参已经相当于定义v为局部变量
      v= 200

-nonlocal 语句
  作用：
    告诉解释器，nonlocal声明的变量不是局部变量，也不是全局变量
    而是外部嵌套函数的变量
  语法：
    nonlocal 变量名1,变量名2, ...
  说明：
    1.nonlocal 语句只能在被嵌套函数内部进行使用
    2.对nonlocal变量进行赋值将对外部嵌套函数作用域内的变量进行操作
    3.当有两层或两层以上函数嵌套时，访问nonlocal变量只对最近的一层
      变量进行操作
    4.nonlocal语句的变量列表里的变量名不能出现在此函数的形参列表中
-练习：(见 test 10)
  用全局变量记录一个函数hello的调用次数
  部分代码如下：
    count = 0
    def hello(name):
      print("您好",name)
      ...
    hello("xiaozhang")
    hello("xiaoli)
    print("hello函数共被调用",count,"次")

-lambda 表达式(又称匿名函数)
  作用：
    创建一个匿名函数对象
    与def 类似，但不提供函数名
  语法：
    lambda [函数形参列表]:表达式
  示例：
    def myadd(x, y):
        return x + y
    #用lambda表达式创建上面的函数
    myadd1 = lambda x,y: x +y

    print("20+30=",myadd1(20,30))
    print("4+5=",myadd1(4,5))
    另：
    fn = lambda : print("hello")  #合法
    fn = lambda *args:print(args) #合法
  说明：
    1.lambda 表达式创建的函数只能包含一条表达式
    2.lambda 比函数简单，且可以随时创建和销毁，有利于降低程序的
      耦合度
  练习：
    1.写一个lambda表达式(见test 12)
      fx = lambda n: ....
    此表达式创建的函数判断n这个数的平方+1能否被5整除，如果能被5
    整除则返回True,否则返回False
      print(fx(3))
      print(fx(4))
    2.写一个lambda表达式来创建函数，此函数返回两个参数的最大值
      (见test 13)
      def mymax(a,b):
          ....
      mymax = lambda ...
      print(mymax(100,200))
    3.看懂下面的程序在做什么，结果是什么？
      def fx(f,x,y):
          print(f(x,y))
      fx((lambda a,b:a + b),100,200)  #300
      fx((lambda x,y:x**y),3,4)       #81

-eval函数和exec()函数
  eval(source,global=None,local=None),把一个字符串source当成一个表达式
    来执行，返回表达式执行后的结果
  exec(source,global=None,local=None),把一个字符串source当成一个程序来
    执行
  eval例：
    例1：
      s = "1 + 2 * 3 + 4"
      v = eval(s)
      print(v)     #11
    例2：
      s = "x + y"
      d1 = {'x':100, 'y':200}
      d2 = {'x':1}
      print(eval(s,d1,d2))  # 201

  exec例：
    s = "while 1:\
          print("aaa")"
    exec(s)    #  aaa aaa aaa
-练习：
  1.给出一个数n，写一个函数来计算
    1 + 2 + 3 + ... + n 的和
    要求用函数来做
    如：
      print(mysum(100))  # 5050
  2.给出一个数n，写一个函数myfac来计算n!(n的阶乘)
    n! = 1*2*3*...*n
    print(myfac(5))    # 120
  3.给出一个数n，写一个函数来计算
    1 + 2**2 + 3**3 + ... + n**n的和
  4.实现带界面的学生信息管理系统，界面如下：
    +--------------------+
    |1)添加学生信息       |
    |2)查看学生信息       |
    |3)删除学生信息       |
    |4)修改学生信息       |
    |q)退出              |
    +--------------------+
    请选择：
    要求每个功能写一个函数与之相对应(复用之前的学生信息管理
    程序)
  5.周末作业
    登录注册程序

---------------------------------------------------------------------------------------------------------
**************************** 2018年10月18日  星期四 小雨  day11********************************************

-函数式编程
    1.函数式编程是指用一系列函数解决问题
    2.函数是一等公民(Guido),要优先对待，多写函数，把庞大的功能拆解成
      一个个小函数
  好处：
    1.用每个函数完成细小的功能，一系列函数的任意组合可以解决大问题
    2.函数进接收输入并产生输出，不包含任何能影响输出的内部状态

-函数的可重入性
    当一个函数的输入实参一定，结果也必然一定的函数称为可重入函数
  说明：
    可重入函数在函数内部一定不访问除局部变量以外的变量
  示例：
    #可重入函数：
      def myadd(x,y):
          return x + y
    #不可重入函数
      s = 0
      def myadd(x,y):
          global s
          s += x + y
          return s

-高阶函数 High Order Function
    map  filter  sorted
  什么是高阶函数：
    满足下列条件中一个的函数即为高阶函数：
      1.函数接受一个或多个函数作为参数传入
      2.函数返回一个函数
-map 函数
  map(func, *iterable)  返回一个可迭代对象，此可迭代对象用函数
    func对可迭代对象iterable中的每一个元素作为参数计算后得一结果，
    当最短的一个可迭代对象(*iterable为元组形参，可以接收任意个可
    迭代对象)不再提供数据时，可迭代对象生成数据结束
  示例：
    例1：
    def power2(x):
        return x**2
    #生成一个可迭代对象,此可迭代对象可以生成1~9的整数的平方
    for x in map(power2,range(1,10)):
        print(x)
    例2：
    #生成一个可迭代对象 1**4, 2**3, 3**2, 4**1
    def mypower2(x,y):
        return x ** y
    for x in map(mypower2,[1,2,3,4],[4,3,2,1]):
        print(x)
    练习：
    1.看懂以下程式在做什么
    for x in map(pow,[1,2,3,4],[4,3,2,1],range(5,10)):
        print(x) 
    2.求：(见 test 1)
      1**2 + 2**2 + 3**2 + ... + 9**2的和 
    3.求：(见 test 1)
      1**3 + 2**3 + 3**3 + ... + 9**3的和
    4.求：(见 test 1)
      1**9 + 2**8 + 3**7 + ... + 9**1的和
    
-filter函数：
  filter(function,iterable)  返回一个可迭代对象
    此可迭代对象将iterable提供的数据用函数function,进行筛选，
    function将对iterable中的每个元素求值,返回False将此数据
    遗弃,返回True则保留
  示例：
    def isodd(x):
      return x % 2 == 1
    #打印0-10之间所有的奇数：
      for x in filter(isodd,range(11)):
          print(x)

-sorted 函数
  作用：
    将原可迭代对象提供的数据进行排序，生成排序后的列表
  语法：
    sorted(iterable,key = None, reverse = False) 返回一个新的包含所有
    可迭代对象中数据的列表，新的列表是排序过的列表
    字符串也可排序
  参数说明：
    key      传入函数,用来提供一个值，这个值将作为排序的依据
    reverse  设置是否降序排列(默认为升序)
  示例：
    L = [5, -2, -4, 0, 3, 1]
    L2 = sorted(L)           #L2 = [-4, -2, 0, 1, 3, 5]
    L3 = sorted(K, Key=abs)  #L4=[0, 1, -2, 3, -4, 5]  按绝对值排序

    names = ['Tom', 'Jerry', 'Spike', 'Tyke']
    L4 = sorted(names)         # ['Jerry', 'Spike', 'Tom', 'Tyke']
    L5 = sorted(names,key=len) # 以字符串长度为依据排序 ['Tom', 'Tyke', 'Jerry', 'Spike']
  练习：(见test 2)
    names = ['Tom', 'Jerry', 'Spike', 'Tyke']
    排序的依据是：
      'moT' 'yrreJ'  'ekipS' 'ekyT'
    结果为：
      ['Spike', 'Tyke', 'Tom', 'Jerry']

-递归函数 recursion
    函数直接或者间接地调用自身
  示例：
    #函数直接调用自身
    def f1():
        print("调用f1")
        f1()
    f1()
    
    #函数间接调用自身
    def fa():
        fb()
    def fb():
        fa()
    fa()
  递归说明：
    递归一定要控制递归的层数，当符合某一条件时，要终止递归调用，几乎所有
    的递归都能用while循环来代替
  递归的优缺点：
    优点：递归可以把问题简单化，让思路更为清晰，代码更简洁
    缺点：递归因系统环境影响大，当递归深度太大时，可能会得到不可预知的结果
  递归函数的执行分为两个阶段：
    递推阶段：调用进入函数内部
    回归阶段：返回结果，得到最终结果
  示例：
    def fx(n):
        print("递归进入第",n,"层")
        if n ==3 :
            return
        fx(n+1)
        print("递归退出第",n,"层")
    fx(1)
    print("程式退出")
  --------结果--------
    递归进入第 1 层
    递归进入第 2 层
    递归进入第 3 层
    递归退出第 2 层
    递归退出第 1 层
    程式退出
  练习：(见 test 3)
    试用递归方式实现
    1+2+3+5+...+n的和
    def mysum(n):
        ...
    print(mysum(100))  #5050
    print(mysum(10000)) #??

-闭包 closure
    闭包是指引用了此函数外部变量的函数(指：外部嵌套函数作用域内的变量)，
    闭包包含函数本身和其运行环境(即函数本身以及外部嵌套作用域)
  闭包必须满足三个条件：
    1.必须有一个内嵌函数
    2.内嵌函数必须引用外部函数的变量
    3.外部函数返回值必须是内嵌函数
  注意点：
    由于闭包会使得函数中的变量都被保留在内存中，内存消耗比较大，所以
    不能滥用闭包
  示例：(另例见 test 4)
    def make_power(y):
        def fn(x):      #fn 绑定一个闭包函数
            return x**y
        return fn
    pow2 = make_power(2)
    print("5的平方是:",pow2(5))

    pow3 = make_power(3)
    print("6的立方是:",pow3(6))
  练习：
    试看下列程序的执行结果是什么：
      def get_funs(n):
          L = []
          for i in range(n):
              L.append(lambda x : x*i)  # lambda表达式return的是 x * i,i是变量,遍历到最后一次i=3
          return L
      funs = get_funs(4):  # 所以该列表[x*i, x*i, x*i, x*i] i最后绑定的是3
      print(funs[0](10))  #??  -->30
      print(funs[1](10))  #??  -->30
      print(funs[2](10))  #??  -->30
      print(funs[3](10))  #??  -->30
-练习:
  1.写程式解决下面的问题：
    已知有五位朋友在一起
      第五位朋友说他比第四位朋友大2岁
      第四位朋友说他比第三位朋友大2岁
      第三位朋友说他比第二位朋友大2岁
      第二位朋友说他比第一位朋友大2岁
      第一位朋友说他10岁
    分别打印出上述五个人的年龄
  2.已知有列表：
    L = [[3, 5, 8], 10, [[13, 14], 15, 18], 20]
    1)写一个函数print_list(lst)打印出所有的数字
      print_list(L)  #打印3 5 8 10 13
    2)写一个函数sum_list(lst)返回这个列表所有数字的和
      print(sum_list(L))  #106
    注：
      type(x) 可以返回一个变量的类型
  3.改写之前的学生信息管理程序，添加4个功能：
    |5)按学生成绩高-低显示学生信息       |
    |6)按学生成绩低-高显示学生信息       |
    |7)按学生年龄高-低显示学生信息       |
    |8)按学生年龄低-高显示学生信息       |

     
---------------------------------------------------------------------------------------------------------
**************************** 2018年10月19日  星期五 晴  day12 ********************************************
-装饰器 decorators
    1.装饰器是一个函数，主要作用是用来包装另一个函数或类(后面会讲到)
    2.包装的目的是在不改变原函数名(或类名)的情况下改变或添加被包装对象的行为
-函数装饰器
    是指装饰器传入的是一个函数，返回的也是一个函数
  语法：
    def 装饰器函数名(参数):
        语句块
        return 函数对象
    @装饰器函数名<换行>
    def 函数名(形参列表):
        语句块
  示例：
    原理示意：见test 1 & test 2
    应用示意: 模拟银行项目，见 test 3

-函数的文档字符串
    函数内第一次未赋值给任何变量的字符串是此函数的文档字符串
  语法：
    def 函数名(参数列表):
      '函数的文档字符串'
      语句块
  示例:
    def hello(name):
        '''这是一个向别人问好的函数
        name 绑定人的姓名'''
        pass
  说明：
    1.给函数的调用者一定的说明,可以用help(函数名)查看,主要说明本函数
      的功能和使用方法：1.形参含义，2.输出
    2.函数的文档字符串绑定在函数对象的__doc__属性上

  函数的__doc__属性(__是两个下划线)
    __doc__属性用于绑定函数的文档字符串

-函数定义语句的完整语法(方括号代表可省略)
  [@装饰器名1]
  [@装饰器名2]
  ...
  def 函数名([位置形参], [*元组形参], [命名关键字形参], [**字典形参]):
      '''文档字符串'''
      语句块
-----------------------函数相关内容到此结束----------------------------------

-模块 module
    模块是一个包含有一系列的数据、函数、类等组成的程序组
    模块是一个文件，模块文件通常以.py结尾
  作用：
    1.让一些相关的数据，函数，类等有逻辑地组织在一起，使逻辑
      结构更加清晰
    2.模块中的数据，函数和类等可以提供给其他的模块或程序调用
  模块的分类：
    1.内置模块，在解析器的内部可以直接使用
    2.标准库模块，安装python时已安装，可直接使用
    3.第三方模块(通常为开源)，需自己安装
        $pip3 install 模块名
    4.用户自己编写的模块(可以作为其他人的第三方模块)

-模块的导入 import语句

-import语句
  语法：
    import 模块名1 [as 模块新名1], 模块2 [as 模块新名2], ...
  作用：
    将某模块整体导入到当前模块
  示例：
    import math
    import sys, os
  用法：
    模块名，属性名
    math.factorial(5)
  练习：(见test 4)
    1.输入一个圆的半径，打印出这个圆的面积
    2.输入一个圆的面积，打印出这个圆的半径
  
-dir(obj) 函数： 返回一个字符串列表
    1.如果无参调用，则返回当前作用域内所有变量的列表
    2.如果给定一个对象作为参数，返回这个对象所有变量的列表
        对于一个模块，返回这个模块的所有变量(属性)
        对于一个类对象，返回类对象的所有变量，并递归基类对象
          的所有变量
        对于其他对象，返回所有变量，类变量和基类变量

-help(obj) 函数，查看模块相关的文档字符串

-from import语句
  语法：
    from 模块名 import 模块属性名1 [as 属性新名1], \
               模块属性名2 [as 属性新名2], ......
  作用：
    将某模块内的一个或多个属性导入到当前模块的作用域
  示例：
    from math import sin, cos, tan
    from math import pi
    from math import factorial as fac
    print(sin(pi/2)*fac(5))
-from import *语句
  语法:
    from 模块名 import *
  作用：
    将某模块的所有属性导入到当前模块
  示例：
    from math import *
    print(factorial(5))
    print(sin(pi/2))

-数学模块
  模块名：math
-时间模块
    提供了时间相关的函数
  用法：
    import time
    # 或
    from time import xxx
    # 或
    from time import *
  时间简介：
    1.公元纪年是从公元 0000年1月1日0时开始的
    2.计算机元年是从1970年1月1日0时开始的,此时时间为0,之后每过一秒时间+1
    3.UTC 时间 (Coordinated Universal Time) 是从Greenwich时间开始计算的.
    4.UTC 时间不会因时区问题而产生错误
    5.DST 阳光节约时间(Daylight Saving Time)，又称夏令时, 是一个经过日照时间修正后的时间
  时间元组：
    时间元组是一个9个整型元素组成的,这九个元素自前至后依次为:
        四位的年(如: 1993)
        月 (1-12)
        日 (1-31)
        时 (0-23)
        分 (0-59)
        秒 (0-59)
        星期几 (0-6, 周一是 0)
        元旦开始日 (1-366)
        夏令时修正时间 (-1, 0 or 1).
    注：
        如果年份值小于100,则会自动转换为加上1900后的值
  时间模块：
      数据 	                   描述
  time.altzone 	          夏令时时间与UTC时间差(秒为单位)
  time.daylight 	        夏令时校正时间
  time.timezone 	        本地区时间与UTC时间差(秒为单位)
  time.tzname 	          时区名字的元组， 第一个名字为未经夏令时修正的时区名,
                          第一个名字为经夏令时修正后的时区名
  注： CST为中国标准时间(China Standard Time UTC+8:00)
      函数名 	                  描述
  time.time() 	          返回从计算机元年至当前时间的秒数的浮点数(UTC时间为准)
  time.sleep(secs) 	      让程序按给定秒数的浮点数睡眠一段时间
  time.gmtime([secs])     用给定秒数转换为用UTC表达的时间元组
                          (缺省返回当前UTC时间元组)
  time.asctime([tuple]) 	将时间元组转换为日期时间字符串(无参则返回当地时间)
  time.mktime(tuple) 	    将本地日期时间元组转换为新纪元UTC秒数时间
  time.localtime([secs]) 	将UTC秒数时间转换为日期元组（无参以本地时间为准)
  time.ctime()            返回当前时间： Fri Nov 16 11:27:38 2018
 
  练习：(见test 5)
    写一个程序，输入你的出生日期
    1.算出你已经出生了多少天了？
    2.算出你出生那天是星期几？

-时间模块1 - datetime
  datetime.datetime.now()
  datetime.date
  datetime.time

-系统模块 sys
   运行时系统相关的信息
  文档参见：
  sys模块的数据
      数据 	                       描述
    sys.path 	                模块搜索路径 path[0] 是当前脚本程序的路径名，否则为 ''
                              在这些路径下的模块才可被导入
    sys.modules 	            已加载模块的字典
    sys.version             	版本信息字符串
    sys.version_info 	        版本信息的命名元组
    sys.platform 	            操作系统平台名称信息
    sys.argv 	                命令行参数 argv[0] 代表当前脚本程序路径名  ???
    sys.copyright 	          获得Python版权相关的信息
    sys.builtin_module_names 	获得Python内建模块的名称（字符串元组）
  sys模块的函数
      函数名 	                    描述
    sys.exit([arg]) 	        退出程序，正常退出时sys.exit()
    sys.getrecursionlimit() 	得到递归嵌套层次限制（栈的深度）
    sys.setrecursionlimit(n) 	得到和修改递归嵌套层次限制（栈的深度）

-os模块
  os.path.exists('文件名')    判断文件是否存在
  os.remove('文件名')        删除文件
  os.path.getsize(filename)  获取文件大小
  os.listdir([path])         查看路径中的文件，返回'文件名'列表
  os.path.isfile(path)       判断是否是普通文件

-练习
  1.写一个程式，以电子时钟的格式打印时间:
    格式:
      HH:MM:SS
    要求:每秒钟变化一次
  2.编写一个闹钟程序，启动时设置定时时间，到时间后打印一句
    时间到，然后退出程序
  3.编写函数fun，功能是计算下列多项式的和
    Sn = 1 + 1/1! + 1/2! + 1/3! + ... + 1/n!
    建议用数学模块里的factorial
    求n=500的值
  4.写程式求：
    1/1 - 1/3 + 1/5 - 1/7 + 1/9 .. (+-)1/(2*n-1)
    的和
    n最大数取 1000000
    打印这个和
    打印这个和乘以4的值(圆周率)

---------------------------------------------------------------------------------------------------------
**************************** 2018年10月22日  星期一 晴  day13 ********************************************
-自定义模块
  要求：
    1.模块文件名后缀必须以.py结尾
    2.模块文件名必须是合法的标识符
    3.避免和內建模块名冲突(import sys --> sys.builtin_module_names查看)
  导入方式：
    import语句
    from xx import 语句
    from xx import *
  示例见：
    mymod.py --> test 1 示例导入mymod.py并使用

-import 语句查找模块文件的路径
    import 模块名  
  1.搜索內建模块
  2.搜索程序运行时的路径(当前路径)
  3.sys.path 提供的路径
    sys.path 是一个列表，内部存入的都是模块的搜索路径
      >>> import sys
      >>> print(sys.path)

-导入第三方模块或包
    pip3 install 模块名
      会自动根据模块名下载相应模块并安装

-让import语句能找到自己的模块：
  1.把自己写的模块放到sys.path中的某个文件夹内
  2.修改sys.path列表，在内部添加一个文件夹的字符串
    (注：此做法只对当前程序起作用)
  如：
    import sys
    sys.path.append("/home/tarena/test")

-模块化编程
  优点：
    1.有利于多人合作开发
    2.使代码更加易于维护
    3.提高代码的复用率
    4.有利于解决变量名冲突问题(模块内的全局变量的作用域为模块内全局)

-模块的加载过程
  1.在模块导入时，模块内的所有语句会被执行
  2.如果一个模块已经被导入，再次导入时不会重新执行模块内的语句
    除非用improt imp   用imp.reload(模块名) 强制重新加载模块

-模块被导入和执行的过程
    1.先搜索相关路径找到  模块名.py
    2.判断是否有此模块对应的.pyc文件,如果.pyc文件比.py文件新，则直接
      加载.pyc文件
    3.如果.pyc文件比.py文件旧，则用模块名.py生成.pyc文件，并加载执行
  模块的编译：
          编译          解释执行
  mymod.py --> mymod.pyc --> python3

-模块的属性
  __doc__属性
    用于绑定模块的文档字符串
    模块的文档字符串用于help(模块名)函数提供帮助信息
  __file__属性
    用于绑定模块的文件路径名
  __name__属性
    __name__属性用来记录模块自身的名字
    作用：
      1.记录模块名
      2.用来判断是否为主模块
    说明:
      当模块作为主模块(也就是第一个运行的模块)运行时，
      __name__属性 绑定'__main__'
      当此模块不是主模块时，__name__绑定模块名
      如：
        mymod.py 的模块名为'mymod'
  __all__ 列表
    作用：
      当用from xxx import *语句导入时，只导入__all__列表内的属性
    说明：
      __all__列表是一个用来存放可导出属性的字符串列表
    示例见：
      test 2

-模块的隐藏属性
    模块中以'_'开头的属性，在用from xxx import *导入时，将不被导入，
    通常称这些属性为隐藏属性
  示例：
    mymod2.py

-随机模块 random
  作用：
    用于模拟或生成随机输出的模块
  文档参见：
    import random as R
    函数名 	                                  描述
   R.random() 	                        返回一个[0, 1) 之间的随机实数
   R.uniform(a,b) 	                    返回[a,b] 区间内的随机实数
   R.randint(a, b) 	                    返回在[a, b]范围内的整数(包含a,b)
   R.randrange([start,] stop[, step]) 	返回range(start,stop,step)中的随机数
   R.choice(seq) 	                      从序列中返回随意一个元素
   R.shuffle(seq[, random]) 	          随机指定序列的顺序(乱序序列）
   R.sample(seq,n) 	                    从序列中选择n个随机且不重复的元素,返回列表
  练习：
    1.用random模块，随机为自己生成一个6位数的数字密码(见 test 3)
    2.猜数字游戏：(见 test 4)
      让程序随机生成一个整数(0-100)之间，用变量x绑定，让用户循环输入整数
      用y绑定
        如果y > x则提示用户"您猜大了"
        如果y < x则提示用户"您猜小了"
        如果y = x则提示用户"恭喜您猜对了"，然后退出循环输入
        并打印猜数字的次数

-包(模块包)  package
    包是将模块以文件夹的组织形式进行分组管理的方法
  作用：
    将一系列模块进行分类管理，有利于防止命名冲突
    可以在需要时加载一个或部分模块，而不是全部模块
  示例：
    mypack/
      __init__.py
      menu.py
      games/
        __init__.py
        contra.py
        supermario.py
        tanks.py
      office/
        __init__.py
        excel.py
        word.py
-包的导入
  同模块的导入规则
  import 包名 [as 包别名]
  import 包名.模块名 [as 模块新名]
  import 包名.子包名.模块名 [as 模块新名]

  from 包名 import 模块名 [as 模块新名]
  from 包名.子包名 import 模块名 [as 模块新名]
  from 包名.子包名.模块名 import 属性名 [as 属性新名]

  from 包名 import *
  from 包名.模块名 import
  ...

-__init__.py 文件
  __init__.py 是常规包内必须存在的文件
  __init__.py 会在包加载时被自动调用
  
  作用：
    1.编写此包的内容
    2.填写包的文档字符串
    3.在__init__.py文件可以加载此包所依赖的其他模块

-__init__.py 内的 __all__列表
  作用：
    用来记录此包中有哪些包或模块需要导入
    当用from包import *语句导入模块时，只查找__all__中所有的模块
    或子包
  说明：
    __all__列表 只在from xxx import * 起作用
  示例：
    __all__ = ['contra', 'tanks']  用from mypack.games import *导入时
                                   只导入contra和tanks模块

-import 语句搜索包的路径的顺序
  1.搜索程序运行时的路径(当前工作目录)
  2.sys.path提供的路径 

-包的相对导入
    指包内模块的相互导入
  语法：
    from 相对路径包或模块 import 属性或模块名
    或
    from 相对路径包或模块 import
  相对路径：
    在from import语句和 from import * 语句中可以使用相对路径
    .代表当前目录
    ..代表上一级目录
    ...代表上二级目录
    ....以此类推    
    ex:
      from ..main import games
  注：相对导入时不能超出包的外部
  示例：
    mypack/games/contra.py      

-练习：
  1.模拟斗地主发牌，牌共54张
    黑桃('\u2660'), 梅花('\u2663'), 红桃('\u2666'), 方块('\u2665')
    A, 2-10, JQK, 大王, 小王 
  三个人，每人发17张牌，底牌留三张
    输入回车，打印第一个人的十七张牌
    输入回车，打印第二个人的十七张牌
    输入回车，打印第三个人的十七张牌
    输入回车，打印第四个人的十七张牌
    输入回车，打印三张底牌
  2.修改原学生信息管理程序，将程序拆分为模块：
    要求：
      1.主事件循环放在main.py中
      2.show_menu函数放在menu.py中
      3.与学生操作相关的函数放在studen_info.py中
  3.打印杨辉三角(只打印6层)
          1
         1 1
        1 2 1
       1 3 3 1
      1 4 6 4 1
    1 5 10 10 5 1

---------------------------------------------------------------------------------------------------------
**************************** 2018年10月23日  星期二 晴  day14 ********************************************

-异常 exception(基础)
  什么是错误：
    错误是指由于逻辑或语法等导致程序无法正常执行的问题
  特点：
    无法预知
  什么是异常：
    异常是程序出错时标识的一种状态，当异常发生时，程序不会再向下
    执行，而转去调用此函数的地方，待处理此错误并恢复为正常状态
  作用： 
    用作信号通知，通知上层调用者有错误产生需要处理

-try语句 的两种用法
    try-except语句
    try-finally语句
  -try-except语句的语法：
    try:
        可能触发异常的语句
    except 错误类型1 [as 变量1]:
        异常处理语句1
    except 错误类型2 [as 变量2]:
        异常处理语句2
    except (错误类型3, 错误类型4, ...) [as 变量3]:
        异常处理语句3
    ...
    except:   #可以捕获任意类型的错误
        异常处理语句other
    else:
        未发生异常的语句，只有在没有发生任何异常时才会执行
    finally:
      最终语句，无论是否发生异常，该语句一定会执行
    通常要捕获所有错误时:
      except Exception as err:
  作用：
    尝试捕获错误，得到异常通知，将程式由异常状态转换为正常状态
    并继续执行
  说明：
    as 子句是用于绑定错误对象的变量，可以省略
    except 子句可以有一个或多个，但至少有一个
    else 子句最多只能有一个，也可以省略
    finally 子句最多只能有一个，也可以省略
  示例见：
    test 1
  练习：(见 test 2)
    写一个函数，get_score()来获取学生输入的成绩信息(0-100)的整数，如果
    输入异常，则此函数返回0，否则返回用户输入的成绩
      def get_score():
          ...
      score = get_score()
      print("学生的成绩是:",score)
  
  -try-finally语句
    语法：
      try:
          可能触发异常的语句
      finally:
          最终语句
    说明:
      finally子句不可以省略
      一定不存在except子句
    作用：
      通常try-finally语句用来做触发异常时必须要处理的事情
      无论异常是否发生，finally子句都会被执行
    注：
      try-finally语句不会改变程序的(正常/异常)状态
    示例：
      1.(见test 4)
      2.改写以下程序，避免崩溃：(见test 5)
        def get_number():
            s = input("请输入整数:") or '0' #如果输入空字符串s会绑定'0'
            i = int(s)
            return s
        print(get_number())

-python3中全部的错误类型：
  文档参见：
         错误类型 	         说明
    ZeroDivisionError 	  除(或取模)零 (所有数据类型)
    ValueError 	          传入无效的参数
    AssertionError 	      断言语句失败
    StopIteration 	      迭代器没有更多的值
    IndexError 	          序列中没有此索引(index)
    IndentationError 	    缩进错误
    OSError 	            输入/输出操作失败
    ImportError 	        导入模块/对象失败
    NameError 	          未声明/初始化对象 (没有属性)
    AttributeError 	      对象没有这个属性
    GeneratorExit 	      生成器(generator)发生异常来通知退出
    TypeError 	          对类型无效的操作
    KeyboardInterrupt 	  用户中断执行(通常是输入^C)
    OverflowError 	      数值运算超出最大限制
    FloatingPointError 	  浮点计算错误
    BaseException 	      所有异常的基类
    SystemExit 	          解释器请求退出
    Exception 	          常规错误的基类
    StandardError 	      所有的内建标准异常的基类
    ArithmeticError 	    所有数值计算错误的基类
    EOFError 	            没有内建输入,到达EOF 标记
    EnvironmentError 	    操作系统错误的基类
    WindowsError 	        系统调用失败
    LookupError 	        无效数据查询的基类
    KeyError 	            映射中没有这个键
    MemoryError 	        内存溢出错误(对于Python 解释器不是致命的)
    UnboundLocalError 	  访问未初始化的本地变量
    ReferenceError 	      弱引用(Weak reference)试图访问已经垃圾回收了的对象
    RuntimeError 	        一般的运行时错误
    NotImplementedError 	尚未实现的方法
    SyntaxError           Python语法错误
    TabError 	            Tab 和空格混用
    SystemError 	        一般的解释器系统错误
    UnicodeError 	        Unicode 相关的错误
    UnicodeDecodeError 	  Unicode 解码时的错误
    UnicodeEncodeError   	Unicode 编码时错误
    UnicodeTranslateError Unicode 转换时错误
以下为警告类型 	
    Warning 	            警告的基类
    DeprecationWarning 	  关于被弃用的特征的警告
    FutureWarning 	      关于构造将来语义会有改变的警告
    OverflowWarning 	    旧的关于自动提升为长整型(long)的警告
    PendingDeprecationWarning 	关于特性将会被废弃的警告
    RuntimeWarning 	      可疑的运行时行为(runtime behavior)的警告
    SyntaxWarning 	      可疑的语法的警告
    UserWarning 	        用户代码生成的警告
    详见：help(builtins) 	

-raise语句
  作用：
    触发一个错误，让程序进入异常状态
    发送错误通知给调用者
  语法：
    raise 异常类型
    或
    raise 异常对象
    或
    raise #重新触发上一次异常
  示例：
    见test 6
    见test 7
  练习：(见test 8)
    写一个函数get_age()用来获取一个人的年龄信息，此函数规定
    用户只能输入1~140之间的整数，如果用户输入其他的数据，则
    直接触发ValueError类型的错误报告：
      def get_age():
         ...
      try:
        age = get_age()
        print("用户输入的年龄是:",age)
      except ValueError as err:
          print("用户输入的不是1-140之间的整数，获取年龄失败") 

-assert语句 (断言语句)
  语法：
    assert 真值表达式, 错误数据(通常是字符串)
  作用：
    当真值表达式为False时，用错误数据创建一个AssertionError类型的
    错误，并进入异常状态，通常用来故意制造一个错误
  等同于：
    if bool(真值表达式) == False:
        raise AssertionError(错误数据)    
  示例：
    见test 9

-迭代器 iterator
    迭代器是访问可迭代对象的工具
    迭代器是iter(obj) 函数返回的对象(实例)
    迭代器可以用next(it) 函数获取可迭代的对象数据

-迭代器函数 iter() 和 next()
    -iter(iterable)从可迭代对象中获取一个迭代器，iterable
      必须是能提供一个迭代器的可迭代对象
    -next(iterator) 从迭代器iterator中获取下一个记录，如果无法
      获取下一条记录，则触发StopIteration异常
  说明：
    迭代器只能往后取值，不会回退
    用iter函数可以返回一个可迭代对象的迭代器
  示例：
    例1.
    L = [2, 3, 5, 7]
    it = iter(L)   #从L对象中获取一个迭代器
    print(next(it))  #2
    print(next(it))  #3
    print(next(it))  #5
    print(next(it))  #7
    print(next(it))  #StopIteration异常

    例2.
    it = iter(range(1,10,3))
    print(next(it))  #1
    print(next(it))  #4
    print(next(it))  #7
    print(next(it))  #StopIteration异常
  练习：(见test 11)
    有一个集合
      s = {'唐僧', '悟坑', '八戒', '沙僧'}
    用while语句和迭代器实现访问以上内容
-练习：
  1.一个球从100m高空下落,每次落地后反弹高度为原高度的一半，
    再落下，写程序算出：
      1)皮球在第10次落下后反弹多高
      2)算出皮球在第10次反弹后经过多少米路程
  2.分解质因数，输入一个正整数，分解质因数
    如 输入：90 则打印 90 = 2*3*3*5
    (质因数是指最小能被原数整除的素数(不包括1))
  3.修改原学生信息管理程序，加入异常处理语句，让程序在任何情况下都能
    按逻辑正常执行.
      如输入成绩，年龄等不会导致程序崩溃(见day13-exercise)
    

---------------------------------------------------------------------------------------------------------
**************************** 2018年10月24日  星期三 晴  day15 ********************************************
-生成器 generator
    1.生成器是能够动态提供数据的可迭代对象
    2.生成器在程序运行时生成数据，与容器类不同，它通常不会在
      内存中保存大量的数据，而是现用现生成
  优点：
    不占用计算机的内存
  生成器有两种：
    1.生成器函数
    2.生成器表达式

-生成器函数的定义
    含有yield语句的函数是生成器函数，此函数被调用将返回一个生
    成器对象
  yield 翻译为(产生或生成)

-yield语句
  语法：
    yield 表达式
  说明：
    yield只能用于def函数中，目的是将此函数作为生成器函数使用
    yield 用来生成数据，供迭代器的next(it)函数使用
  示例见：
    test 1
  说明：
    1.生成器函数的调用将返回一个生成器对象，生成器对象是一个可迭代
      对象
    2.生成器函数用return会触发一个StopIteration异常
    3.生成器对象是一次性的，一旦生成结束，将不能再重新生成数据
      例：
        r = range(5)
        for x in r:
          print(x)   #0 1 2 3 4
        for x in r:
          print(x)    #什么都没有
  生成器的作用：
    见 test 3
  练习：(见test 4)
    写一个生成器函数myevent(start,stop)用来生成从start开始，到stop结束
    (不包含stop)区间范围内的一系列偶数
      def myeven(start,stop):
          ...
      evens = list(myeven(10,20))
      print(evens)
      for x in myeven(21,30):
          print(x)

-生成器表达式
  语法：
    (表达式 for 变量 in 可迭代对象 [if 真值表达式])
  作用：
    用推导式形式创建一个新的生成器
  说明：
    1.if 子句可以省略
    2.生成器表达式也可以像列表推导式一样嵌套
    3.类似列表推导式，只是当被访问时才现用现生成每个元素
  示例：
    gen = (x**2 for x in range(1,5))
    for x in gen:
        print(x)  # 1 4 9 16
  练习：(见test 5)
    已知有列表:
      L = [2, 3, 5, 7]
    1)写一个生成器函数，让此函数能够动态提供数据，提供的数
      据为原列表的数字的平方加1
    2)写一个生成器表达式，让此表达式能够动态提供数据，提供
      的数据为列表的数字的平方加1
    3)创建一个列表，此列表内的数据为原列表的数字的平方加1
  练习2：
    1.试写一个生成器myfilter函数，此函数与系统內建的filter
      函数功能一致(见test 6)
    2.看懂下列程序：
      程序1：
        L = [2, 3, 5, 7]
        a = [x*10 for x in L]
        it iter(a)
        print(next(it))  # 20
        L[1] = 333
        print(next(it))  # 30
      程序2：
        L = [2, 3, 5, 7]
        a = (x*10 for x in L)
        it iter(a)
        print(next(it))  # 20
        L[1] = 333
        print(next(it))  #  3330   

-迭代工具函数
  作用：
    生成一个符号条件的可迭代对象
  语法：
    zip(iter1[, iter2, ...]) 返回一个zip生成器对象，此对象
      用于生成一个元组，此元组的数据分布来自于参数中的每一个
      可迭代对象，生成的元组的数据个数由最小的可迭代对象决定 

    enumerate(iterable, start=0) 返回一个enumerate生成器对象，
      此对象生成类型为(索引,值)的元组，索引默认从零开始，也可以
      用start指定
  示例：
    numbers = [10086, 10000, 10010, 95588]
    names = ['中国移动', '中国电信', '中国联通']   
    for t in zip(numbers, names):
        print(t)
    dict(zip(numbers, names))
  练习：(见test 7)
    写一个程式，输入任意行文字，当输入空行时结束输入，
    打印带有行号的输入结果
    如：
      请输入：hello<回车>
      请输入：abc<回车>
      请输入：tarena<回车>
      请输入：<回车>
    打印如下：
      第1行:hello
      第2行:abc
      第3行:tarena

-字节串(字节序列) bytes
    存储以字节为单位的数据
    字节串是不可变的字节序列
  说明：
    字节是0~255之间的整数，用来表示一个字节的取值
    1byte = 8 bits
  创建空字节串的字面值方式：
    b''
    b""
    b''''''
    b""""""
  创建非空字节串的字面值
    b'ABCD'
    b"ABC"
    b'''aaaa'''
    b"""bbbb"""
  字节串的构造函数 bytes
    bytes()              生成一个空的字节串,等同于b''
    bytes(整数可迭代对象) 用可迭代对象初始化一个字节串
    bytes(整数n)         生成n个值为0的字节串
    bytes(字符串,encoding='utf-8') 用字节串转换编码生成一个字节串

  示例：
    B = bytes()
    B = bytes(range(0x41, 0x61))
    B = bytes([65, 66, 67, 68])
    B = bytes(10)
    B = bytes("hello", 'utf-8')
    B = bytes("中文", 'utf-8')  #一个中文占用3个字节
  字节串的运算：
    + += * *=
    < <= > >= == !=
    in / not in
    索引和切片
  可用的函数：
    len(x), max(x), min(x), sum(x)
    any(x), all(x)
  bytes 与 str的区别:
    bytes 存储字节(0~256之间的整数)
    str 存储unicode字符(0~0x10FFFF)的字符
  bytes 与 str 的转换:
        编码(encode)
    str -----------> bytes
      b = s.encode(encoding='utf-8')

        解码(decode)
    bytes ----------> str
      s = b.decode(encoding='utf-8')
  
  示例：
    s = "ABC中文"
    b = s.encode('utf-8') #参数缺省值就是'utf-8'
    s2 = b.decode('utf-8')
    print(s, b, s2)

-字节数组 bytearray
    可变的字节串
  字节数组的构造函数 bytearray
    bytearray()
    bytearray(整数可迭代对象)
    bytearray(整数n)
    bytearray(字符串,encoding='utf-8')
  运算：
    同字节串
    注：字节数组支持索引和切片赋值
  字节数组的方法：
      方法 	                             说明
    B.clear() 	                清空
    B.append(n) 	              追加一个字节(n为0-255的整数)
    B.remove(value) 	          删除第一个出现的字节,如果没有出现，则产生ValueError错误
    B.reverse() 	              字节的顺序进行反转
    B.decode(encoding='utf-8')  解码 	
    B.find(sub[, start[, end]]) 查找对象，返回索引 	

-练习：
  1.写一个生成器函数myxrange([start, ]stop[, step])
    生成一系列的整数
    要求myxrange功能与range函数功能完全相同
    (不允许调用range函数和列表)
    用自己写的myxrange,结合生成器表达式求100以内所有奇数
    的平方和
  2.写一个生成器函数fibonacci,生成斐波那契数的前n个数
    1 1 2 3 5 8 ...
    如：
      def fibonacci(n):
          ...
          yield ...
          ...
      1)打印前20个数:
        for x in fibonacci(20)
            print(x)
      2)打印前40个斐波那契数的和
        print(sum(fibonacci(40)))
  3.思考题:
    如何让学生管理系统启动时就能读取文件中的信息来加载数据？
    (预习文件操作)

---------------------------------------------------------------------------------------------------------
**************************** 2018年10月25日  星期四 晴  day16 ********************************************
-文件 file
    文件是用于存储数据的基本单位
    文件通常是用来长期存储数据
    文件中数据是以字节为单位进行顺序存储的

-文件的操作流程
  1.打开文件
  2.读/写文件
  3.关闭文件
  注:任何的操作系统，一个应用程序同时打开文件的数量有最大
     数限制

-文件的打开函数
  open(filename,mode='rt',encoding='utf-8',newline='')用于打开一个文件，返回用来操作此文件
        的文件流对象，如果打开失败，则会触发OSError
        mode = 默认'rt'  r=read,t=text "以文本方式读"
      **encoding指定文件的编码方式
        ex:
          open('1.txt','wt',encoding='utf-8')
      **newline指定是否每次写入都以新的一行写(空行)

  打开的文件对象可迭代，每次迭代返回一行内容
  文件流对象的关闭方法
    F.close()  关闭文件.释放系统资源
  示例：
    见test 1

-python3的文本文件模式
  模式字符't'
  说明：
    1.对文本文件的读写操作需要用字符串(str)进行
    2.在读写过程中会自动进行编码(encode)和解码(decode)操作
    3.以行为单位分隔,在python内部统一用'\n'作为换行符进行分隔
      各操作系统的换行符:
        linux: '\n'
        Windows: '\r\n'
        Mac OS:  '\n'

-文本文件的写操作
  方法：
    F.write(x)
    F.writelines(列表)
  模式字符串:
    'w' 写
    'x'
    'a'
  说明：
    当需要写入时，打开文件时模式字符串要填写模式字符串，否则默认'rt'只可读不可写

-python中文本文件的读写操作
  文档参见：
    python文件常用方法:
    -----------------------------------------------------------------------------------------
    mode模式字符的含义
    字符 	  含义
    'r' 	以只读方式打开(默认)
    'w' 	以只写方式打开，删除原有文件内容(如果文件不存在，则创建该文件并以只写方式打开)
    'x' 	创建一个新文件, 并以写模式打开这个文件,如果文件存在则会产生"FileExistsError"错误
    'a' 	以只写文件打开一个文件，如果有原文件则追加到文件末尾
    'b' 	用二进制模式打开
    't' 	文本文件模式打开 (默认)
    '+' 	为更新内容打开一个磁盘文件 (可读可写)

    缺省模式是 'rt'
    'w+b' 可以实现二进制随机读写，当打开文件时，文件内容将被清零
    'r+b' 以二进制读和更新模式打开文件,打开文件时不会清空文件内容
    'r+'  以文本模式读和更新模式打开文件,打开文件时不会清空文件内容
    ----------------------------------------------------------------------------------------
      方法 	                             说明
    F.close() 	                关闭文件(关闭后文件不能再读写会发生ValueError错误)

    读取数据方法 	
    F.read(size=-1) 	          从一个文件流中最多读取size个字符(文本文件)或字节(二进制文件),
                                  如果不给出参数，则默认读取文件中全部的内容并返回
    F.readline() 	              每调用一次读取一行数据, 如果到达文件尾则返回空字符串
    F.readlines(max_chars=-1) 	返回每行字符串的列表,max_chars为最大字符(或字节)数

    写入数据方法 	
    F.write(text)        	      写一个字符串到文件流中，返回写入的字符数(文本文件)或字节数(二进制文件)
    F.writelines(lines) 	      将字符串的列表或字符串的列表中的内容写入文件
    F.tell() 	                  返回当前文件流读写指针的绝对位置(字节为单位),类似字节的索引
    F.seek(offset, whence=0) 	  改变数据流读写指针的位置，返回新的绝对位置
      作用：
        设置文件的读写位置，返回新的读写位置
      格式：
        F.seek(偏移量,whence=相对位置)
          偏移量：
            大于0代表向文件末尾方向移动
            小于0代表向文件头方向移动
          相对位置：
            0 代表从文件头开始偏移
            1 代表从当前读写位置开始偏移
            2 代表从文件尾开始偏移
      示例：test 9
    F.flush() 	                把写入文件对象的缓存内容写入到磁盘
      示例：test 10
    ----------------------------------------------------------------------------------------------
  示例：
    F.readlines()示例见test 4  返回每行字符串的列表  #['ABCD\n', '1234\n', '我是中文\n']
    F.read() 示例见 test 5
    F.write/F.writelines 见test 6
  
  练习：(见test3)
    1.自己写一个文件'info.txt'，内部存储以下文字信息如下：
      张三,20,100
      李四,18,98
      小王,22,95
    写程序将以上数据读取出来，并以如下格式打印在屏幕终端上：
      张三 今年 20 岁,成绩是: 100
      李四 今年 18 岁,成绩是: 98
      小王 今年 22 岁,成绩是: 95
    2.(见project/student_sys)
      写一个程式，输入很多人的姓名，年龄，成绩，存于文件'infos.txt'中
      文件格式自己定义(建议用逗号分隔各信息)
      完成输入后查看文件格式是不是您想要的格式(用文本文件进行操作)
     L = input_student()
     def save_to_file(L,filename='infos.txt')
         ...
     save_to_file()

-以十六进制方式显示文件内容的命令：
  $ xxd 文件名
  (vscode可以安装以16进制显示文件的插件hexdump)

-二进制文件操作
    二进制模式字符: 'b'
    默认文件中存储的都是以字节(byte)为单位的数据，通常认为的格式
    对二进制文件的读写需要用字节串(bytes)或字节数组(bytearray)进行操作

  对二进制文件读写方法都需要用字节为单位进行操作
    F.read(n)
    F.readline()
    F.readlines()
    F.write(字节串)
    F.writelines(字节串组成的列表)
  示例：
    例1. f = open(文件名,'rb') #读取到的是字节串
    例2. 见test 7 
  二进制文件写操作示例：
    见 test 8

-标准输入输出文件：
  模块名：
    sys
  常用选项：
    sys.stdin     标准输入文件(默认为键盘)
    sys.stdout    标准输出文件(默认为屏幕终端)
    sys.stderr    标准错误输出文件(默认为屏幕终端)
  说明：
    标准文件不需要打开即可使用，也不用手动关闭
  示例：
    test 11  #标准输出文件
    test 12  #标准输入文件
    
-汉字的编码(只有两种)
  国标系列:
    GB18030(二字节或四字节编码,27533个字)
      GBK(二字节编码,20013个字)
        GB2313(二字节编码,约7千多个字)
    (windows常用)
  国际标准系列:
    Unicode称统一码,又称万国码
    Unicode(Unicode16/Unicode32)  <--> utf-8
    (Linux/ Mac OS X/ IOS/ Android 常用)

      utf-8中：(它是针对unicode的可变长度编码,8bit-Unicode Transformation Format)
        英文ASCII(0x0 - 0x7F)     一字节
                 (0x80 - 0x3FF)   二字节  
                 (0x400 - 0xFFFF) 三字节(中文在此区)

-python 编码字符串:
  'gb2312'
  'gbk'
  'gb18030'
  'utf-8'
  'ascii'
  ...
  如：
    s = "你好"
    print(s.encode('gb2312'))
    print(s.encode('gbk'))              
    print(s.encode('gb18030'))              
    print(s.encode('utf-8'))              
    print(s.encode('ascii'))       #出错，'你好'不在ascii编码范围

-编码注释：
  在源文件中，第一行或第二行写入的如下内容是编码注释:
    # -*- coding:gbk -*-
    或
    # -*- coding:utf-8 -*-     
  如果没有注释，python会默认此文件是uft-8编码的   

-练习：
  1.写程式实现复制文件的功能
    要求：
      1.要考虑超大文件问题
      2.要能复制二进制文件(如:图片等)
      3.要考虑关闭文件
  2.改写原学生管理程式，要求加入如下两个功能：
    |9)从文件中读取数据(si.txt)       |
    |10)保存信息到文件(si.txt)        |

---------------------------------------------------------------------------------------------------------
**************************** 2018年10月26日  星期五 晴  day17 ********************************************
------------------------------------↑↑↑面向过程编程↑↑↑----------------------------------------------------
  最小单位：函数
  经典案例:学生管理系统

------------------------------------↓↓↓面向对象编程↓↓↓----------------------------------------------------
                            -- ojbect-Oriented Programming --
-什么是面向对象：
    把一切看成对象(实例)用各种对象之间的关系来描述事物 
  最小单位：
    类 class

-什么是对象：
    对象是指现实中的物体或实体
  对象都有什么特征
    对象有很多的属性(名词,形容词)
      姓名,年龄,姓名,肤色,...
    对象有很多行为(动词,动作)
      吃饭,学习,睡觉,踢球,...
  说明：
    对象(实例)可以调用类方法和实例方法
    对象(实例)可以有自己的作用域和名字空间,可以为该实例添加实例变量(也叫实例属性) 

-什么是类
    拥有相同属性和行为的对象分为一组，即为一个类
    类是用来描述对象的工具，用类可以创建此类的对象(实例)
  示例：
    车(类)  --->  对象: BYD E6(京A.88888)的一辆车
            \-->  对象: BMW X6(京B.00000)车

    狗(类) ---> 对象:谁谁家的小京巴(户籍号:00001)
            \-> 对象:XX导盲犬(户籍号:00002)

    int(类) ---> 100 (对象)
             \-> 200 (对象)

-类的创建语句:
  语法：
    class 类名(继承列表):
      '''类的文档字符串'''
      实例方法(类内的函数method)定义
      类变量
      类方法(@classmethod)
      静态方法(@staticmethod)
  作用：
    创建一个类
    类用于描述对象的行为和属性
    类用于创建此类的一个或多个对象(实例)
  说明:
    类名必须是标识符
    类名实质是变量,它绑定一个类
  示例：
    (见test 1)

-构造函数
  格式：
    类名([传参列表])
  作用:
    创建这个类的实例对象，并返回此实例对象的引用关系
  示例：
    test 2

-实例方法(instance method)
  定义格式：
    class 类名(继承列表):
        def 实例方法名(self, 参数1, 参数2, ...):
            '''方法的文档字符串'''
            语句块
  作用：
    用于描述一个对象的行为,让此类型的全部对象都可以拥有相同的行为
  说明:
    实例方法的实质是函数,是定义在类内的函数
    实例方法至少有一个形参,第一个形参绑定调用此方法的实例,一般名为'self'
  实例方法的调用语法：
    实例.实例方法名(调用传参)    #粤B666.refuel(10)
    或
    类名.实例方法名(实例,调用传参) #car.refuel(粤B666,10)
  示例:
    test 3

-实例属性 attribute (也叫实例变量)
    每个实例可以用自己的变量来记录自己的数据，这个变量称为实例变量
  使用语法:
    实例.属性名
  赋值规则:
    首次为属性赋值则创建此属性
    再次为属性赋值则改变此属性的绑定关系
  作用：
    记录对象自身的数据

-练习：(见test 5)
  定义一个'人'类：
    class human:
        def set_info(self,name,age,adress='不详'):
            ...
        def show_info(self):
            '''打印此人的信息'''
            ...
    s1 = human()
    s1.set_info('小张',20,'北京市东城区')
    s2 = human()
    s2.set_info('小李',18)

    s1.show_info() #小张 今年 20 岁,家住: ...
    s2.show_info() #小李 今年 18 岁,家住: 不详

-删除属性：
    del 对象.实例变量名
  示例：
    dog1.fav = ['游泳', '吃骨头','玩球']
    del dog1.fav

-初始化方法
  作用：
    对新创建的对象添加属性
  语法格式：
    class 类名(继承列表):
        def __init__(self[, 形参列表]):
            语句块
    注：[]代表其中的内容可以省略
  说明：
    1.初始化方法的名必须是"__init__"，不可更改
    2.初始化方法会在构造函数创建实例后自动调用，且将实例自身通过第一个
      参数self传入"__init__"方法中
    3.构造函数的实参将通过__init__方法的参数列表传入到__init__方法中
    4.初始化方法内如果需要return返回,则必须返回None
  示例：
    test 6

-练习：(见test 7)
  写一个学生类student,此类用于描述学生信息，包含：姓名，年龄，成绩(默认为0)
  1)为该类添加初始化方法,实现在创建对象时自动设置:
      name, age, score 属性
  2)添加set_score方法,能为对象修改成绩信息
  3)添加show_info方法打印学生对象的信息
  如：
    class student:
      def __init__(self,name,age,score=0):
          ...
      def set_score(...):
          ...
      def show_info(...):
          ...
    L = []
    L.append(student('小张', 20, 100))
    L.append(student('小李', 18, 95))
    L.append(student('小钱', 19, 50))
    L[-1].set_score(70)
    for s in L:
        s.show_info()

-析构方法：
  格式：
    class 类名(继承列表):
        def __del__(self):
            ...
  作用:
    在此对象销毁前释放此对象所占用的资源(如关闭打开的文件等)
  说明:
    析构方法在对象被销毁前自动调用
    python语言建议不要在对象销毁时做任何事情，因为销毁的时间难以确定
  对象生命周期：
    创建对象 --> __init__ --> 使用对象 --> __del__ --> 销毁对象
  示例：
    test 8

-预置实例属性
  __dict__属性
    __dict__属性绑定一个存储此实例自身变量的字典
  
  示例：
    class dog:
        pass
    dog1 = dog()
    print(dog1.__dict__)  #{}
    dog1.color = '白色'
    print(dog1.__dict__)  #{'color': '白色'}
    #直接访问该字典也可以为该对象创建属性，但不推荐,如↓↓
    dog1.__dict__['kinds'] = '导盲犬'

  __class__ 属性
    作用：
      可以借助此属性来访问创建此实例的类
    示例：
      class dog:
          pass
      dog1 = dog()
      print(dog1.__class__)
      #当想创建与dog1同类的对象时
      dog2 = dog1.__class__()    #等同于dog2 = dog()

-用于实例对象的函数:
  isinstance(obj, class_or_tuple)  返回这个obj对象是否是某个类的对象，
    或者某些类中一个类的对象，如果是则返回True，否则返回False
  type(obj)  返回对象的类型

  示例：
    class dog:
        pass
    dog1 = dog()
    isinstance(dog1, dog)                   #true
    isinstance([1, 2, 3], dog)              #False
    isinstance([1, 2, 3], (int , str))      #False
    isinstance([1, 2, 3], (int, str, list)) #True
    type(dog1) is dog

-练习(见test 9)
  有两个人:
    第一个人: 姓名：张三， 年龄：35岁
    第二个人：姓名：李四， 年龄：15岁
  行为：
    1.教别人学东西     teach
    2.工作赚钱         work
    3.借钱            borrow
    4.显示自己的信息   show_info
  事情：
    张三 教 李四 学 python 
    #(学一样东西，多一项技能，每个人应添加技能属性)
    李四 教 张三 学 王者荣耀
    张三 上班赚了 1000 元钱
    李四 向 张三 借钱 200元
    35 岁的 张三 有钱 800元，他学会的技能是: 王者荣耀
    15 岁的 李四 有钱 200元，他学会的技能是：python

-练习：
  1.完全数：
    1 + 2 + 3 = 6 (6为完全数)
      1,2,3都为6的因数(能够被一个数x整除的数y,则x为y的因数)
      1 x 6 = 6
      2 x 3 = 6
    完全数是指除自身以外的所有因数之和相加等于自身的数
    求4-5个完全数
    答案: 6, 28, 496, ...
  2.将学生信息管理程序改写,把用于存储学生信息的字典，换成用student
    类型对象来存储学生信息

---------------------------------------------------------------------------------------------------------
**************************** 2018年10月29日  星期一 晴  day18 ********************************************
-类
  定义方法：
    class 类名:
  类也是对象，该对象由类名绑定。类是能创建实例的对象

-类变量
    类变量是类的属性，此属性属于类，不属于此类的实例
  作用:
    通常用来存储该类创建的对象的共有属性
  说明:
    类变量可以通过该类直接访问
    类变量可以通过类的实例直接访问(取值)
    类变量可以通过此类对象的__class__属性间接访问
  示例见:
    test 1 & test 2
  注：
    实例方法和类方法都是类的变量，也叫类变量

-类的文档字符串
    类内第一个没有赋值给任何变量的字符串为类的文档字符串
    类的文档字符串绑定在类的__doc__属性上
  示例：
    class dog:
        '''dog类的文档字符串'''
        def infos(self):
            '''这是dog类内infos方法的文档字符串'''

    >>> help(dog)
    >>> print(dog.__doc__)

-类的__slots__列表：
  作用：
    1.限定一个类创建的实例只能在固定的属性(实例变量)不允许对象添加
      此列表以外的实例属性
    2.防止用户因错写属性名而发生程序错误
    3.添加__slots__以外的实例属性会触发AttributeError
  说明：
    1.__slots__属性是一个列表，列表的值是字符串
    2.含有__slots__属性的类所创建的实例对象没有__dict__属性，此实例
      不要字典来存储实例属性
  示例：
    test 3

-类方法 @classmethod
    类方法是用于描述类的行为的方法，类方法属于类，不属于该类创建的对象
  说明：
    1.类方法需要使用@classmethod装饰器定义
    2.类方法至少有一个形参，第一个形参用于绑定类，约定写成cls
    3.类和该类的实例都可以调用类方法(见test 5)
    4.类方法不能访问此类创建的对象的实例属性
  示例：
    test 4

-静态方法 @staticmethod
    静态方法是定义在类内的函数，此函数的作用域是类的内部
  说明：
    1.静态方法需要使用@staticmethod装饰器定义
    2.静态方法与普通函数定义相同，不需要传入self和cls参数
    3.静态方法只能凭借该类或类的实例调用
    4.静态方法不能访问类变量和实例变量
  实例见：
    test 6

-函数，静态方法，类方法，实例方法：
  共性：
    语句块，实现相应功能
-练习：(见student.py & student_oop.py)
  1.用类来描述一个学生的信息(也可以改写之前的student类)
    学生信息有：
      姓名，年龄，成绩
    将这些学生对象存于列表中，可以任意添加和删除学生信息：
      1)打印出学生的个数
      2)打印出所有学生的平均成绩
      3)打印出所有学生的平均年龄
        (建议用类变量来记录学生的信息的列表)

-继承 inheritance 和 派生 derived
  什么是继承/派生:
    派生就是从一个已有的类中衍生出新类
    继承是指在衍生出的新类中的对象会拥有原类的属性和行为
  例：
    船(类)----- 渔船(类)
            |-- 客船(类) ----- 游轮(类)
            |-- 货船(类)   \-- 快艇(类) 

    船派生了 渔船、客船、货船，渔船继承了 船，其他同理...
  作用：
    用继承派生机制，可以将一些共有功能加在基类中，实现代码共享
    在不改变基类代码的基础上，改变原有类的功能
  名词：
    基类(base class)/ 超类(super class)/ 父类(father class)
    派生类(derived class)/ 子类(child class)

-单继承
  语法：
    class 类名(基类名):
        语句块
  说明：
    单继承是指派生类由一个基类衍生出来的类
  示例：
    test 7
  
-继承说明：
  python3中任何类都直接或间接地继承自object类
  object类是一切类的超类

-类的__base__属性
  __base__属性用来记录此类的基类,不能用实例来调用

-python內建类的继承关系见:
  >>> help(__builtins__)

-覆盖 override
    覆盖是指在有继承关系的类中，子类中实现了与基类同名的方法，在子类
    的实例调用该方法时，实际调用的是子类的覆盖版本，这种现象叫做覆盖
  作用：
    实现和父类同名，但功能不同的方法
  示例：
    test 8
  问题：
    当覆盖发生时，如何调用父类的被覆盖方法??(见test 9,但不推荐;推荐使用super函数)

-super函数
  super(cls,obj) 返回绑定超类的实例(要求obj必须是cls类或cls子类的对象)
    相当于把obj当成cls的上一级父类的对象
  super() 返回绑定超类的实例，等同于:
    super(__class__,实例方法的第一个参数)，必须在方法内调用
  
  作用：借助super()返回的实例间接调用父类的覆盖方法
  实例见：
    test 10

-super函数的应用
  显式调用基类的初始化方法
    当子类中实现了__init__方法，基类的__init__方法将不会被自动调用，
    如果需要调用，则需要用super显示调用
  示例：
    test 11

-练习:
  1.写一个类Bicycle自行车类，有run方法，调用时显示骑行的里程km
    class Bicycle:
        def run(self,km):
            print("自行车骑行了", km, "公里")
    1)再写一个Ebicycle电动自行车类，在Bicycle的基础上添加了电池
      电量volume属性,有两种方法:
        fill_charge(vol) 用来充电 vol为电量
        run(km) 方法,每骑行10km消耗电量1度,同时显示剩余电量,当电量耗尽
        则调用Bicycle的run方法(用脚蹬骑行)
      class Ebicycle:
          ...
      b = Ebicycle(5)    #新买的电动车有5度电
      b.run(10)          #电动骑行了10km,还剩4度电
      b.run(100)         #电动骑行了40km,还剩0度电,用脚蹬骑行了60km
      b.fill_charge(10)  #电动车充电10度
      b.run(50)          #电动骑行了50km,还剩5度电

---------------------------------------------------------------------------------------------------------
**************************** 2018年10月30日  星期二 晴  day19 ********************************************      

-用于类的函数：
  issubclass(cls,class_or_tuple) 判断一个类是否继承自某个类class或
    某些类tuple中的一个类，如果是则返回True,否则返回False
  示例：
    class A:
        pass
    class B(A):
        pass
    class C(B):
        pass
    issubclass(C,B) # True
    issubclass(C,A) # True

-封装
    1.封装是指隐藏类的实现细节，让使用者不关心这些细节
    2.封装的目的是让使用者通过尽可能少的方法(或属性)操作对象
  私有属性和方法：
    python类中以双下滑线__开头,不以双下滑线结尾的标识符为私有成员，
    私有成员只能使用该类的方法进行访问和修改
  示例:
    test 1

-编程语言的状态:
    静态(编译时状态)  # C/ C++
    动态(运行时状态)  # C++/ Java

-多态 polymorphic
    1.字面意思: '多种状态'
    2.多态原指在有继承关系的类中，调用基类对象的方法，实际能调用到子类覆盖
      方法的现象叫多态
  说明：
    python全部的对象都只有"运行时状态(动态)",没有C++语言里面的编译时
    状态(静态)
  示例：
    test 2

-面向对象的编程语言的特征：
  1.继承/派生
  2.封装
  3.多态

-多继承 multiple inheritance
    多继承是指一个子类继承自两个或两个以上的基类
  语法：
    class 类名(基类名1,基类名2, ...):
  说明：
    1.一个子类同时继承多个父类，父类中的方法可以同时被继承下来
    2.如果两个父类中有同名的方法，而在子类中又没有覆盖此方法，调用
      结果难以确定  
  示例：
    test 3
  
-多继承的问题(缺陷)
    标识符(名字空间)冲突的问题
    要谨慎使用多继承
  说明:
    支持多继承的语言 C++/ python
    不支持多继承    Java/ C#/ swif/ Objective-C
  示例:
    test 4

-多继承的MRO问题 (Method Resolution Order)
    MRO --> 方法的解决顺序
    类的__mro__属性
  作用：
    用来记录类的方法的查找顺序
  示例:
    面试题 test 5

-对象转换字符串函数的使用
    repr(obj) 返回一个符合python语法规则的字符串
      通常:
        eval(repr(obj))  == obj

    str(obj) 通过给定的对象返回一个字符串(这个字符串通常是
      给人阅读的)
  说明：
    以上两个函数返回的一定是字符串
  示例：
    test 6
  
-函数的重写
    函数重写是指在自定义的类内添加相应的方法，让自定义的类创建
    的实例可以像內建对象一样进行函数操作

-对象转换字符串的重写方法
  repr(obj) 函数的重写方法
    def __repr__(self):
        return '字符串'
  str(obj) 函数的重写方法:
    def __str__(self):
        return '字符串'
  示例：
    test 7

-str函数调用方法说明:
  1.先调用obj.__str__()方法取值
  2.如果obj.__str__()方法不存在，则调用obj.__repr__()方法取值
  3.如果再不存在obj.__repr__()方法，则调用object类的__repr__
    方法取值

-內建函数的重写
    方法名             函数名
  __abs__(self)      abs(obj)  函数
  __len__(self)      len(obj)  函数
  __reversed__(self) reversed(obj)
  __round__(self)    round(obj)

  示例见:
    test 8

-数值转换函数重写
    方法名              函数名
  __complex__(self)    complex(obj)
  __int__(self)        int(obj)
  __float__(self)      float(obj)
  __bool__(self)       bool(obj)
  示例见:
    test 9

-布尔测试函数(bool)的重写
  作用：
    用于bool(obj)函数取值
    用于if语句的真值表达式
    用于while语句的真值表达式中
  说明：
    1.优先调用obj.__bool__()方法进行取值
    2.当不存在obj.__bool__()方法时，用obj.__len__()的返回值是否
      为零来测定布尔值，当不存在__len__()时，则直接返回True
  示例见:
    test 10

-对象的属性管理函数
  函数 	                                说明
  getattr(obj, name[, default]) 	从一个对象得到对象的属性；getattr(x, 'y') 等同于x.y; 当属性不存在时,如果给
                                    出default参数,则返回default,如果没有给出default 则产生一个AttributeError错误
  hasattr(obj, name) 	            用给定的name返回对象obj是否有此属性,此种做法可以避免在getattr(obj, name)时引发错误
  setattr(obj, name, value)    	  给对象obj的名为name的属性设置相应的值value, set(x, 'y', v) 等同于 x.y = v
  delattr(obj, name) 	            删除对象obj中的name属性, delattr(x, 'y') 等同于 del x.y

-迭代器(高级)
  什么是迭代器
    可以通过next(it)函数取值的对象就是迭代器
  迭代器协议：
    迭代器协议是指对象能够使用next函数获取下一项数据，在没有
    下一项数据是触发一个StopIteration异常来终止迭代的约定
  迭代器协议实现的方法:
    __next__(self) 方法来实现迭代器协议

-什么是可迭代对象
    是指能够用iter(obj)函数返回迭代器的对象(实例)
    可迭代对象的内部要定义__iter__(self)方法来返回迭代器对象(实例)
  实例见:
    test 11 & test 12

-标识符命名法:
  1.匈牙利命名法:
       单词小写,词间用下划线_分隔
    例：
      my_range
  2.驼峰命名法:(写类名通常用大驼峰命名法,国际约定俗成的命名法)
    1)大驼峰
      每个单词的首字母均大写
      如:
        MyRangList
    2)小驼峰
      第一个单词小写,其后每个单词首字母大写
      如:
        myRangList

-练习
  1.修改之前的学生信息管理系统(见project/stu_system_v1.0)
      要求将学生的姓名、年龄、成绩属性进行封装，不让除Student类之外
      的方法访问和修改
  2.实现一个与系统內建的range类相同功能的类myrange:
    class myrange:
        def __init__(self,...):
            ...
        def __iter__(self):
            ...
    实现如下功能:
      L = list(myrange(10))
      print(L)                    # [0,1,2,...,9]
      print(sum(myrange(1,101)))  # 5050  
      L2 = [x**2 for x in myrange(1,10,3)]
      print(L2)
      for x in myrange(10,0,-3):
          print(x)  # 10, 7, 4, 1

---------------------------------------------------------------------------------------------------------
**************************** 2018年10月31日  星期三  晴  day20 ********************************************
-with语句
  语法:
    with 表达式1 [as 变量1], 表达式2[as 变量2], ...:
        语句块
  作用:
    使用于对资源进行访问的场合，确保使用过程中不管是否发生异常，都
    会执行必须的"清理"操作，并释放资源
      如:
        文件使用后自动关闭,线程中锁的自动获取和释放等
  说明:
    执行表达式,用as子句中的变量绑定生成的对象
    with语句并不改变异常的状态
  示例：
    见 test 1 & myfilecopy.py
    
-环境管理器
    类内有 __enter__ 和 __exit__实例方法的类被称为环境管理器
  说明：
    1. __enter__将在进入with语句时被调用，并返回由as变量管理的对象
    2. __exit__将在离开with语句时被调用,且可以用参数来判断在离开
       with语句时是否发生异常，并作出相应的处理
  示例:
    test 2

-运算符重载
    让自定义的类生成的对象(实例)能够使用运算符进行操作
  作用：
    让自定义的类的实例想內建对象一样使用运算符，让程序简洁易读
    对自定义的对象将运算符赋予新的运算规则
  
-算术运算符重载
    方法名                运算符和表达式          说明
  __add__(self,rhs)        self + rhs           加法
  __sub__(self,rhs)        self - rhs           减法
  __mul__(self,rhs)        self * rhs           乘法
  __truediv__(self,rhs)    self / rhs           除法
  __floordiv__(self,rhs)   self // rhs          地板除
  __mod__(self,rhs)        self % rhs           求余
  __pow__(self,rhs)        self ** rhs          幂运算

  rhs (right hand side) 右手边
 
  说明：
   运算符重载的方法和参数已经有固定的含义，不建议改变原有的意义
  示例见:
   test 3
  练习：(见test 4)
    实现两个自定义的列表相加
      class MyList:
        def __init__(self,iterable=()):
            ...
    L1 = MyList(range(1,4))
    L2 = MyList([4,5,6])
    L3 = L1 + L2  
    print(L3)  # MyList([1,2,3,4,5,6])
    L4 = L2 + L1
    print(L4)  # MyList([4,5,6,1,2,3])
    L5 = L1 * 2
    print(L5)  # MyList([1,2,3,1,2,3])
    思考:
     L6 = 2 * L2 #可以吗,为什么 

-反向算术运算符的重载
    当运算符左侧为內建类型，右侧为自定义类型时，进行算术运算
    会出现TypeError错误，因无法修改內建类型的代码来实现运算符重载，
    因此需要使用反向运算符重载来完成这项工作

    方法名                运算符和表达式          说明
  __radd__(self,lhs)          lhs +  self          加法
  __rsub__(self,lhs)          lhs -  self          减法
  __rmul__(self,lhs)          lhs *  self          乘法
  __rtruediv__(self,lhs)      lhs /  self          除法
  __rfloordiv__(self,lhs)     lhs // self          地板除
  __rmod__(self,lhs)          lhs %  self          求余
  __rpow__(self,lhs)          lhs ** self          幂运算
  示例:
    见test 4 中 L6 = 2 * L2

-复合赋值算术运算符重载
    以复合赋值算术运算符 x += y为例，此运算符会优先调用x.__iadd__(y)方法,
    如果没有__iadd__方法时会将复合赋值运算符拆解为 x = x + y然后再调用
    x.__add__(y)方法，如果不存在__add__方法则会触发TypeError异常
    其他复合赋值运算符也有同样的规则

    方法名                 运算符和表达式          说明
  __iadd__(self,lhs)       self +  lhs            加法
  __isub__(self,lhs)       self -  lhs            减法
  __imul__(self,lhs)       self *  lhs            乘法
  __itruediv__(self,lhs)   self /  lhs            除法
  __ifloordiv__(self,lhs)  self // lhs            地板除
  __imod__(self,lhs)       self %  lhs            求余
  __ipow__(self,lhs)       self ** lhs            幂运算

  示例：
    见 test 5

-比较运算符的重载
    方法名                运算符合表达式           说明
  __lt__(self,rhs)         self <   rhs          小于
  __le__(self,rhs)         self <=  rhs          小于等于
  __gt__(self,rhs)         self >   rhs          大于
  __ge__(self,rhs)         self >=  rhs          大于等于
  __eq__(self,rhs)         self ==  rhs          等于
  __ne__(self,rhs)         self !=  rhs          不等于
    注:
      l  little
      e  equal
      g  great
      t  than

-位运算符的重载:
    方法名                运算符合表达式           说明
  __and__(self,rhs)        self &   rhs          位与
  __or__(self,rhs)         self |   rhs          位或
  __xor__(self,rhs)        self ^   rhs          位异或
  __lshift__(self,rhs)     self <<  rhs          左移
  __rshift__(self,rhs)     self >>  rhs          右移

-反向位运算符的重载:
    方法名                运算符合表达式           说明
  __rand__(self,lhs)       lhs &  self        位与
  __ror__(self,lhs)        lhs |  self        位或
  __rxor__(self,lhs)       lhs ^  self        位异或
  __rlshift__(self,lhs)    lhs << self        左移
  __rrshift__(self,lhs)    lhs >> self        右移

-复合赋值位运算符的重载:
    方法名                运算符合表达式           说明
  __iand__(self,rhs)      self &=   rhs          位与
  __ior__(self,rhs)       self |=   rhs          位或
  __ixor__(self,rhs)      self ^=   rhs          位异或
  __ilshift__(self,rhs)   self <<=  rhs          左移
  __irshift__(self,rhs)   self >>=  rhs          右移

-一元运算符的重载
    方法名                运算符合表达式           说明
  __neg__(self)           - self                 负号
  __pos__(self)           + self                 正号
  __insert__(self)        ~ self                 取反
  示例:
    见test 6

-in / not in运算符重载
        方法名                运算符合表达式 
  __contains__(self,e)         e in self (同时not in 也可以使用了)
  示例:
    见test 7

-索引和切片运算符重载
    方法名                运算符合表达式           说明
  __getitem__(self,i)      x = self[i]           取值
  __setitem__(self,i,v)    self[i] = v           赋值
  __delitem__(self,i)      del self[i]           删除索引元素
  
  说明:
    实现了__getitem__和__setitem__方法即可以支持索引操作和切片操作
  示例见:
    test 8(索引) & test 9(切片)

-slice 构造函数
  作用:
    用于创建一个slice切片对象,此对象存储一个切片的起始值，终止值和步长信息
    默认都为None
  格式：
    slice(start=None,stop=None,step=None)
  slice对象的属性:
    s.start 切片起始值 默认None
    s.stop  切片的终止值,默认None
    s.step  切片的步长,默认None
  示例:
    test 9
    示例:
     L[::2]  等同于L[slice(None,None,2)]  等同于L.__getitem__(slice(None,None,2))

-特性属性 @property
    实现其他语言所拥有的getter 和 setter功能
  作用：
    用来模拟一个属性
    通过@property装饰器可以对模拟属性的赋值和取值加以控制
  示例：
    test 10

-PEP8编码规范
  文档参见:
  1.代码编排
    1)使用4空格缩进，不使用Tab,更不允许用Tab和空格混合缩进
    2)每行最大长度最大79字节，超过部分使用反斜杠折行(因为终端每行最大长度80字节)
    3)类和全局函数定义间隔两个空行,类内方法定义间隔一个空行.其它地方可以不加空行。

  2.文档编排
    1)其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。
    2)不要在一句import中导入多个模块，比如不推荐import os, sys。
    3)尽可能用import XX 而不采用from XX import YY引用库,因为可能出现名字冲突。

  3.空格的使用
    1)各种右括号前不用加空格
    2)逗号、冒号、分号前不要加空格。
    3)函数的左括号前不要加空格。如func(1)。
    4)序列的左括号前不要加空格。如list[2]。
    5)操作符左右各加一个空格，不要为了对齐增加空格。
    6)函数默认参数使用的赋值符左右省略空格。
    7)不要将多条语句写在同一行，尽管使用‘;’允许。
    8)if/for/while语句中，即使执行语句只有一句，也必须另起一行
    
    原则：避免不必要的空格

-练习：
  写一个简易的httpserver程序，将一个网页文件发送给浏览器显示

++++++++++ 以下自学内容 ++++++++++++++++++++
二、怎么样使程序在后台执行
  方法有很多，这里主要列举两种。假如我们有程序pso.cpp,通过编译后产生可执行文件pso，我们要使pso在linux服务器后台执行。
  当客户端关机后重新登入服务器后继续查看本来在终端输出的运行结果。（假设操作都在当前目录下）
方法1在终端输入命令：
  # ./pso > pso.file 2>&1 & 
  解释：将pso直接放在后台运行，并把终端输出存放在当前目录下的pso.file文件中。
      当客户端关机后重新登陆服务器后，直接查看pso.file文件就可看执行结果（命
      令：#cat pso.file ）。

方法2在终端输入命令：

  # nohup  ./pso > pso.file 2>&1 &

  解释：nohup就是不挂起的意思，将pso直接放在后台运行，并把终端输出存放在当前
  目录下的pso.file文件中。当客户端关机后重新登陆服务器后，直接查看pso.file
  文件就可看执行结果（命令：#cat pso.file ）。

三、常用任务管理命令
  # jobs      //查看任务，返回任务编号n和进程号
  # bg  %n   //将编号为n的任务转后台运行
  # fg  %n   //将编号为n的任务转前台运行
  # ctrl+z    //挂起当前任务
  # ctrl+c    //结束当前任务

  注：如果要使在前天执行任务放到后台运行，则先要用ctrl+z挂起该任务，然后用bg使之后台执行。
  附：在Linux中，如果要让进程在后台运行，一般情况下，我们在命令后面加上&即可，实际上，
      这样是将命令放入到一个作业队列中了：

  但是如上方到后台执行的进程，其父进程还是当前终端shell的进程，而一旦父进程退出，
  则会发送hangup信号给所有子进程，子进程收到hangup以后也会退出。如果我们要在退出shell的时候继续运行进程，
  则需要使用nohup忽略hangup信号，或者setsid将将父进程设为init进程(进程号为1)

  当shell中提示了nohup成功后还需要按终端上键盘任意键退回到shell输入命令窗口，然后通过在shell中输入exit来退出终端；
  而我是每次在nohup执行成功后直接点关闭程序按钮关闭终端.。所以这时候会断掉该命令所对应的session，
  导致nohup对应的进程被通知需要一起shutdown

  如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为
  nohup.out的文件中，除非另外指定了输出文件：

  nohup command > myout.file 2>&1 &
  ex:
    nohup python3 run.py > run.log 2>&1 &

停止后台程序:
  nohup。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。关闭中断后，
  在另一个终端jobs已经无法看到后台跑得程序了，此时利用ps（进程查看命令）
  ps -aux | grep "test.sh"  #a:显示所有程序 u:以用户为主的格式来显示 x:显示所有程序，不以终端机来区分

-ubuntu中防火墙(ufw)基本操作
  1.启用防火墙
    sudo ufw enable
  2.关闭防火墙
    sudo ufw disable
  3.添加防火墙规则
    sudo ufw allow 端口号
  4.查看防火墙状态
    sudo ufw status
